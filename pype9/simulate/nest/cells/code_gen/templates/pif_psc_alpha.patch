--- nest/examples/MyModule/pif_psc_alpha.cpp	2017-09-22 21:07:56.000000000 +1000
+++ nest-2.10/examples/MyModule/pif_psc_alpha.cpp	2017-09-22 21:11:33.000000000 +1000
@@ -20,34 +20,26 @@
  *
  */
 
-#include "pif_psc_alpha.h"
-
-// C++ includes:
-#include <limits>
-
-// Includes from libnestutil:
-#include "numerics.h"
-
-// Includes from nestkernel:
 #include "exceptions.h"
-#include "kernel_manager.h"
-#include "universal_data_logger_impl.h"
-
-// Includes from sli:
+#include "pif_psc_alpha.h"
+#include "network.h"
 #include "dict.h"
-#include "dictutils.h"
-#include "doubledatum.h"
 #include "integerdatum.h"
+#include "doubledatum.h"
+#include "dictutils.h"
+#include "numerics.h"
+#include "universal_data_logger_impl.h"
 #include "lockptrdatum.h"
 
+#include <limits>
+
 using namespace nest;
 
 /* ----------------------------------------------------------------
  * Recordables map
  * ---------------------------------------------------------------- */
 
-nest::RecordablesMap< mynest::pif_psc_alpha >
-  mynest::pif_psc_alpha::recordablesMap_;
+nest::RecordablesMap< mynest::pif_psc_alpha > mynest::pif_psc_alpha::recordablesMap_;
 
 namespace nest
 {
@@ -112,36 +104,30 @@
   updateValue< double >( d, names::t_ref, t_ref );
 
   if ( C_m <= 0 )
-    throw nest::BadProperty(
-      "The membrane capacitance must be strictly positive." );
+    throw nest::BadProperty( "The membrane capacitance must be strictly positive." );
 
   if ( tau_syn <= 0 )
-    throw nest::BadProperty(
-      "The synaptic time constant must be strictly positive." );
+    throw nest::BadProperty( "The synaptic time constant must be strictly positive." );
 
   if ( V_reset >= V_th )
     throw nest::BadProperty( "The reset potential must be below threshold." );
 
   if ( t_ref < 0 )
-    throw nest::BadProperty(
-      "The refractory time must be at least one simulation step." );
+    throw nest::BadProperty( "The refractory time must be at least one simulation step." );
 }
 
 void
 mynest::pif_psc_alpha::State_::get( DictionaryDatum& d ) const
 {
-  // Only the membrane potential is shown in the status; one could show also the
-  // other
+  // Only the membrane potential is shown in the status; one could show also the other
   // state variables
   ( *d )[ names::V_m ] = V_m;
 }
 
 void
-mynest::pif_psc_alpha::State_::set( const DictionaryDatum& d,
-  const Parameters_& p )
+mynest::pif_psc_alpha::State_::set( const DictionaryDatum& d, const Parameters_& p )
 {
-  // Only the membrane potential can be set; one could also make other state
-  // variables
+  // Only the membrane potential can be set; one could also make other state variables
   // settable.
   updateValue< double >( d, names::V_m, V_m );
 }
@@ -220,8 +206,7 @@
 
   // refractory time in steps
   V_.t_ref_steps = Time( Time::ms( P_.t_ref ) ).get_steps();
-  assert(
-    V_.t_ref_steps >= 0 ); // since t_ref_ >= 0, this can only fail in error
+  assert( V_.t_ref_steps >= 0 ); // since t_ref_ >= 0, this can only fail in error
 }
 
 /* ----------------------------------------------------------------
@@ -230,8 +215,8 @@
 
 void
 mynest::pif_psc_alpha::update( Time const& slice_origin,
-  const long from_step,
-  const long to_step )
+  const nest::long_t from_step,
+  const nest::long_t to_step )
 {
   for ( long lag = from_step; lag < to_step; ++lag )
   {
@@ -240,8 +225,7 @@
 
     // update membrane potential
     if ( S_.refr_count == 0 ) // neuron absolute not refractory
-      S_.V_m +=
-        V_.P30 * ( S_.I_ext + P_.I_e ) + V_.P31 * S_.dI_syn + V_.P32 * S_.I_syn;
+      S_.V_m += V_.P30 * ( S_.I_ext + P_.I_e ) + V_.P31 * S_.dI_syn + V_.P32 * S_.I_syn;
     else
       --S_.refr_count; // count down refractory time
 
@@ -259,7 +243,7 @@
       // send spike, and set spike time in archive.
       set_spiketime( Time::step( slice_origin.get_steps() + lag + 1 ) );
       SpikeEvent se;
-      kernel().event_delivery_manager.send( *this, se, lag );
+      network()->send( *this, se, lag );
     }
 
     // add synaptic input currents for this step
@@ -278,9 +262,7 @@
 {
   assert( e.get_delay() > 0 );
 
-  B_.spikes.add_value(
-    e.get_rel_delivery_steps( kernel().simulation_manager.get_slice_origin() ),
-    e.get_weight() );
+  B_.spikes.add_value( e.get_rel_delivery_steps( network()->get_slice_origin() ), e.get_weight() );
 }
 
 void
@@ -289,8 +271,7 @@
   assert( e.get_delay() > 0 );
 
   B_.currents.add_value(
-    e.get_rel_delivery_steps( kernel().simulation_manager.get_slice_origin() ),
-    e.get_weight() * e.get_current() );
+    e.get_rel_delivery_steps( network()->get_slice_origin() ), e.get_weight() * e.get_current() );
 }
 
 // Do not move this function as inline to h-file. It depends on
