{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}
:VERBATIM
:extern double nineml_gsl_normal(double, double);
:extern double nineml_gsl_uniform(double, double);
:extern double nineml_gsl_binomial(double, int);
:extern double nineml_gsl_exponential(double);
:extern double nineml_gsl_poisson(double);
:ENDVERBATIM

TITLE Spiking node generated from 9ML using PyPe9 version {{version}} at '{{timestamp}}'

NEURON {
{% if is_subcomponent %}
    SUFFIX {{component_name}}
    {% for species, ports in componentclass.annotations[PYPE9_NS][ION_SPECIES].iteritems() %}
        {% if species == NONSPECIFIC_CURRENT %}
    NONSPECIFIC_CURRENT {% for port in componentclass.analog_send_ports if port.dimension == units.currentDensity %}{{port.name}}{% if not loop.last %}, {% endif %}{% endfor %}
        {% else %}
    USEION {{species}} 
            {%- for p in ports if p.mode == 'recv' %}
                {%- if loop.first %} READ{% endif %} {{p.name}}{% if not loop.last %},{% endif %}
            {%- endfor %}
            {%- for p in ports if p.mode == 'send' %}
                {%- if loop.first %} WRITE{% endif %} {{p.name}}{% if not loop.last %},{% endif %}
            {%- endfor %}
        {% endif %}

    {% endfor %}
{% else %}
    POINT_PROCESS {{component_name}}
    NONSPECIFIC_CURRENT {% for port in componentclass.analog_send_ports if port.dimension == units.current %}{% if not loop.first %}, {% endif %}{{port.name}}{% endfor %}
{% endif %}

    : T
    RANGE regime_

    :StateVariables:
{% for sv in componentclass.state_variables %}
    RANGE {{sv.name}}
{% endfor %}

    :Parameters
{% for p in componentclass.parameters %}
    RANGE {{p.name}}
{% endfor %}

    :Aliases
{% for alias in chain(componentclass.aliases) %}
    RANGE {{alias.name}}
{% endfor %}
}

UNITS {
    : Define symbols for base units
    (mV) = (millivolt)
    (nA) = (nanoamp)
    (nF) = (nanofarad)
    (uF) = (microfarad)
    (S) = (siemens)
    (uS) = (microsiemens)
    (mM) = (milli/liter)
    (um) = (micrometer)
}

CONSTANT {
    : IDs for regimes, events and conditions 

    : Transition flags
    INIT = -1    
    ON_EVENT = 0

    : Regime ids
{% for regime in componentclass.regimes %}
    {{regime.name | upper}} = {{componentclass.index_of(regime)}}
{% endfor %}

    : Event port ids
{% for port in componentclass.event_receive_ports %}
    {{port.name | upper}} = {{componentclass.index_of(port)}}
{% endfor %}

}

INITIAL {
    : Initialise State Variables:
{% for sv in componentclass.state_variables %}
    {{sv.name}} = 0
{% endfor %}

    : Initialise Regime:
    {# This should come from the initial state, when we sort out that format #}
    regime_ = {{next(componentclass.regimes).name | upper}}

{% if not is_subcomponent %}
    : Initialise the NET_RECEIVE block by sending appropriate flag to itself
    net_send(0, INIT)
{% endif %}
}

PARAMETER {
    : True parameters
{% for param, units in unit_handler.assign_units_to_variables(componentclass.parameters) %}
    {{param.name}} = 0 ({{units}})
{% endfor %}

    : Constants
{% for const, value, units in unit_handler.assign_units_to_constants(componentclass.constants) %}
    {{const.name}} = {{value}} ({{units}})
{% endfor %}

    : Unit correction for 't' used in printf in order to get modlunit to work.
    PER_MS = 1 (/ms)
}

STATE {
{% for sv, units in unit_handler.assign_units_to_variables(componentclass.state_variables) if sv.name != 'v' %}
    {{sv.name}} ({{units}})
{% endfor %}
}



ASSIGNED {
    : Internal flags
    regime_
    found_transition_
{% for port, units in unit_handler.assign_units_to_variables(chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports)) %}
    {{port.name}} ({{units}}) 
{% endfor %}

{% if 'v' in componentclass.state_variable_names %}
    : Membrane voltage
    v (mV)
    
{% endif %}
    : Aliases
{% for alias, units in unit_handler.assign_units_to_aliases(componentclass.aliases) %}
    {{alias.name}} ({{units}})
{% endfor %}
}

BREAKPOINT {
    SOLVE states METHOD {{ode_solver}}
{% set output_analog_exprs = componentclass.required_for(componentclass.all_output_analogs()).expressions + list(componentclass.all_output_analogs()) %}
{% for elem, scaled_expr in unit_handler.scale_rhss(output_analog_exprs) %}
    {{code_gen.assign_str(elem.lhs, scaled_expr)}}
{% endfor %}
{% for elem, scaled_expr in unit_handler.scale_rhss(componentclass.required_for(componentclass.all_time_derivatives()).expressions) if elem not in output_analog_exprs %}
    {{code_gen.assign_str(elem.lhs, scaled_expr)}}
{% endfor %}
}

DERIVATIVE states {
{% for sv in componentclass.state_variables if sv.name not in componentclass.annotations[PYPE9_NS][NO_TIME_DERIVS] %}
    {{sv.name}}' = deriv_{{sv.name}}({{componentclass.required_for(componentclass.all_time_derivatives(sv)).state_variable_names | join(', ')}})
{% endfor %}
}

{% for sv in componentclass.state_variables if sv.name not in componentclass.annotations[PYPE9_NS][NO_TIME_DERIVS] %}
FUNCTION deriv_{{sv.name}}(
    {%- for sv, units in unit_handler.assign_units_to_variables(componentclass.required_for(componentclass.all_time_derivatives(sv)).state_variables) -%}
        {{sv.name}} ({{units}}){%- if loop.last %}{% else %}, {% endif -%}
    {%- endfor %}
    ) ({{unit_handler.assign_units_to_variable(sv, derivative_of=True)}}) {
    {% for regime in componentclass.regimes  if sv.name in regime._time_derivatives %}
    {{elseif(loop.first)}} (regime_ == {{regime.name | upper}}) {
        deriv_{{sv.name}} = {{regime.time_derivative(sv.name).rhs_cstr}}
    {{endif(loop.last)}}
    {% endfor %}
}
{% endfor %}


{% if not is_subcomponent %}
NET_RECEIVE(weight_, channel) {
    INITIAL {
      : stop channel being set to 0 by default
    }
    found_transition_ = -1
    if (flag == INIT) {
        : Set up required watch statements
    {% for regime in componentclass.regimes %}
        {% for oc in regime.on_conditions %}
        WATCH ({{oc.trigger.rhs_cstr}}) {{componentclass.index_of(oc.trigger.rhs, key='TriggerRHS') + 1}}  : Watch trigger of on-condition and send appropriate flag
        {% endfor %}
    {% endfor %}
    {% for regime in componentclass.regimes %}
    } else if (regime_ == {{regime.name | upper}}) {
        {% for trans in regime.transitions %}
            {% if hasattr(trans, 'trigger') %}
        if (flag == {{componentclass.index_of(trans.trigger.rhs, key='TriggerRHS') + 1}}) {  : Condition '{{trans.trigger.rhs_str}}'
            {% else %}
        if (flag == ON_EVENT && channel == {{trans.src_port_name | upper}}) {
            {% endif %}      
            : Required aliases
            {% for elem, scaled_expr in unit_handler.scale_rhss(componentclass.required_for(trans.state_assignments).expressions) %}
            {{code_gen.assign_str(elem.lhs, scaled_expr)}}
            {% endfor %}

            : State assignments
            {% for sa, scaled_expr in unit_handler.scale_rhss(trans.state_assignments) %}
            {{code_gen.assign_str(sa.lhs, scaled_expr)}}
            {% endfor %}

            : Output events
            {% for node in trans.output_events %}
            net_event(t)  : FIXME: Need to specify which output port this is
            {% endfor %}
        
            : Regime transition
            if (found_transition_ == -1) {
                found_transition_ = flag
            } else {
                printf("WARNING!! Found multiple transitions %f and %f at time %f", found_transition_, flag, t * PER_MS)
            }
            regime_ = {{trans.target_regime.name | upper}}
        }
        {% endfor %}
    {% endfor %}
    } else {
        printf("ERROR! Unrecognised regime %f", regime_)
    }
}
{% endif %}
