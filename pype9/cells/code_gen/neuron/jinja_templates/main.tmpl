:VERBATIM
:extern double nineml_gsl_normal(double, double);
:extern double nineml_gsl_uniform(double, double);
:extern double nineml_gsl_binomial(double, int);
:extern double nineml_gsl_exponential(double);
:extern double nineml_gsl_poisson(double);
:ENDVERBATIM

TITLE Spiking node generated from 9ML using PyPe9 version {{version}} at '{{timestamp}}'

NEURON {
    {% if is_subcomponent %}SUFFIX{% else %}POINT_PROCESS{% endif %} {{component.name}}
    RANGE regime

    :StateVariables:
{% for sv in componentclass.state_variables %}
    RANGE {{sv.name}}
{% endfor %}

    :Parameters
{% for p in componentclass.parameters %}
    RANGE {{p.name}}
{% endfor %}

    :Ports
{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    RANGE {{p.name}}
{% endfor %}

    :Aliases
{% for expr in chain(componentclass.aliases, componentclass.piecewises) %}
    RANGE {{expr.lhs}}
{% endfor %}
}

CONSTANT {
    : IDs for regimes, events and conditions 

    : Basic events
    SPIKE = 0
    INIT = 1

    : Regime flags
{% for regime in componentclass.regimes %}
    {{regime.name | upper}} = {{componentclass.index_of(regime)}}
{% endfor %}

    : Event port flags
{% for port in componentclass.event_receive_ports %}
    {{port.name | upper}} = {{componentclass.index_of(port)}}
{% endfor %}

    : On-condition flags
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
    {{regime.name | upper}}_CONDITION_{{componentclass.index_of(oc, key=regime)}}_ = {{componentclass.index_of(oc)}}
    {% endfor %}
{% endfor %}

}

INITIAL {
    : Initialise State Variables:
{% for sv in componentclass.state_variables %}
    {{sv.name}} = 0
{% endfor %}

    : Initialise Regime:
    {# This should come from the initial state, when we sort out that format #}
    regime = {{next(componentclass.regimes).name | upper}}

    : Initialise the NET_RECEIVE block:
    net_send(0, INIT)

    first_round_fired = 0
}

PARAMETER {
    : True parameters
{% for p in componentclass.parameters %}
    {{p.name}} = 0
{% endfor %}

    : Constants
{% for c in componentclass.constants %}
    {{c.name}} = {{c.value}} ({{c.units.name}})
{% endfor %}
}

STATE {
{% for sv in componentclass.state_variables if sv.name != 'v' %}
    {{sv.name}}
{% endfor %}
    first_round_fired
}

ASSIGNED {
    regime
{% for alias in componentclass.aliases %}
    {{alias.lhs}}
{% endfor %}
{% if weight_variables %}
    {% for var in weight_variables.values %}
    {{var}}
    {% endfor %}
{% endif %}
}

BREAKPOINT {
    SOLVE states METHOD {{ode_solver}}
{% for expr in required_td_expressions %}
    {{expr.lhs}} = {{expr.rhs}}
{% endfor %}
}

DERIVATIVE states {
{% for sv in componentclass.state_variables %}
    {{sv.name}}' = deriv_{{sv.name}}({{deriv_args[sv.name]}})
{% endfor %}
}

{% for sv in componentclass.state_variables %}
FUNCTION deriv_{{sv.name}}({{deriv_args[sv.name]}}) {
    {% for regime in componentclass.regimes %}
    if (regime == {{regime.name | upper}}) {
        {% if sv in regime.time_derivatives_map %}
            deriv_{{sv.name}} = {{regime.time_derivatives_map[sv].rhs}}
        {% else %}
            deriv_{{sv.name}} = 0.0
        {% endif %}
    }
    {% endfor %}
}
{% endfor %}

NET_RECEIVE(w, channel) {

    INITIAL {
      : stop channel being set to 0 by default
    }

    if (flag == INIT) {
{% for regime in componentclass.regimes %}
        if (regime == {{regime.name | upper}}) {
    {% for oc in regime.on_conditions %}
            WATCH ({{oc.trigger.rhs}})  {{componentclass.index_of(oc, key=regime)}}
    {% endfor %}
        }
{% endfor %}
    } else if (flag == SPIKE) {
{% for regime in componentclass.regimes %}
        if (regime == {{regime.name | upper}}) {
    {% for oe in regime.on_events %}
        {% set rd = componentclass.required_definitions(oe.state_assignments) %}    
            if (channel == {{oe.src_port_name | upper}}) {
        {% if weight_variables %}
                {{get_weight_variable}}({{channel}}, {{weight_variables}}) = w
        {% endif %}        
                : Expressions
        {% for expr in rd.expressions %}
            {% if hasasttr(expr, 'pieces') %}  {# Is a Piecewise statement #}
                {% for piece in expr.pieces %}
        {% if not loop.first %}else {% endif -%}
                if ({{expr.condition}})
                    {{expr_name}} = {{expr.rhs}}
                {%- endfor %}
                else
                    {{expr_name}} = {{expr.otherwise.rhs}} 
            {% else %}
                {{expr.lhs}} = {{expr.rhs}}
            {% endif %}
        {% endfor %}
        {% for sa in oe.state_assignments %}
                {{sa.lhs}} = {{sa.rhs}}
        {% endfor %}
        {% for node in oe.event_outputs %}
                {{as_expr}}(node)
        {% endfor %}
            }
    {% endfor %}
        }
{% endfor %}
    }

    : First Round of event filtering:
    : Pick up events emitted by WATCH Block.
    : Re-validate them against Conditions and Regime:
    : Retransmit the correct Transition ID

    else if (flag == 4000) {
        if(first_round_fired == 1) {

{% for regime in componentclass.regimes %}
        } else if (regime == {{regime.name | upper}}) {
    {% for oc in regime.on_conditions %}
            if( {{oc.trigger.rhs}} ) {
                net_send(0, {{regime.name | upper}}_CONDITION_{{componentclass.index_of(oc, key=regime)}}_)
            }
    {% endfor %}
{% endfor %}
        }

        : Make sure that we only enter this block once
        first_round_fired = 1
    }

    : Second Round
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
    else if (flag == {{regime.name | upper}}_CONDITION_{{componentclass.index_of(oc, key=regime)}}_) {
        first_round_fired = 0
        regime = {{oc.target_regime.name | upper}}

        {% for node in oc.event_outputs %}
        net_event(t)
        {% endfor %}

        {% for sa in oc.state_assignments %}
        {{sa.lhs}}  = {{sa.rhs}}
        {% endfor %}
    }
    {% endfor %}
{% endfor %}
}
