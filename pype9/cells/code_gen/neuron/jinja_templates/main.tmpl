:VERBATIM
:extern double nineml_gsl_normal(double, double);
:extern double nineml_gsl_uniform(double, double);
:extern double nineml_gsl_binomial(double, int);
:extern double nineml_gsl_exponential(double);
:extern double nineml_gsl_poisson(double);
:ENDVERBATIM

TITLE Spiking node generated from 9ML using PyPe9 version {{version}}

NEURON {
    POINT_PROCESS {{component.name}}
    RANGE regime

    :StateVariables:
{% for sv in componentclass.state_variables %}
    RANGE {{sv.name}}
{% endfor %}

    :Parameters
{% for p in componentclass.parameters %}
    RANGE {{p.name}}
{% endfor %}

    :Aliases
{% for alias in componentclass.aliases %}
    RANGE {{alias.lhs}}
{% endfor %}
}

CONSTANT {
    : Hashes for regimes, events and conditions 

    : Basic events
    SPIKE = 0
    INIT = 1

    : Regime flags
{% for regime in componentclass.regimes %}
    {{regime.name | upper}} = {{hash(regime.name)}}
{% endfor %}

    : Event port flags
{% for port in componentclass.event_receive_ports %}
    {{port.name | upper}} = {{hash(port.name)}}
{% endfor %}

    : Transition flags
{% for regime in componentclass.regimes %}
    {% for oe in regime.on_events %}
    {{(regime.name + '_' + oe.name + '_EVENT_') | upper}} = {{hash(regime.name + oe.name)}}
    {% endfor %}
    
    {% for i, oc in regime.on_conditions %}
    {{(regime.name + '_' + oc.name + '_CONDITION_') | upper}} = {{hash(regime.name + oc.name)}}
    {% endfor %} 
{% endfor %}
}

INITIAL {
    : Initialise State Variables:
{% for var in componentclass.state_variables %}
    {{var.name}} = 0
{% endfor %}

    : Initialise Regime:
    {# This should come from the initial state, when we sort out that format #}
    regime = {{next(componentclass.regimes)).name | upper}}

    : Initialise the NET_RECEIVE block:
    net_send(0, INIT)

    first_round_fired = 0
}

PARAMETER {
    : True parameters
{% for p in componentclass.parameters %}
    {{p.name}} = 0
{% endfor %}

    : Constants
{% for c in componentclass.constants %}
    {{c.name}} = {{c.value}} ({{c.units.name}})
{% endfor %}
}

STATE {
{% for sv in componentclass.state_variables %}
    {{sv.name}}
{% endfor %}
    first_round_fired
}

ASSIGNED {
    regime

{% for alias in componentclass.aliases %}
    {{alias.lhs}}
{% endfor %}
{% for var in weight_variables.values %}
    {{var}}
{% endfor %}
}

BREAKPOINT {
    :SOLVE states METHOD derivimplicit
    SOLVE states METHOD cnexp

{% for alias in componentclass.aliases %}
    {{alias.lhs}} = {{alias.rhs}}
{% endfor %}
}

DERIVATIVE states {
{% for sv in componentclass.state_variables %}
    {{sv.name}}' = deriv_${var.name}({{deriv_func_args(componentclass, sv.name)}}))
{% endfor %}
}

{% for sv in componentclass.state_variables %}
FUNCTION deriv_{{var.name}}({{deriv_func_args(componentclass, sv.name)}})) {
    {% for regime in componentclass.regimes %}
    if (regime == {{regime.name || upper}} ) {
        deriv_{{sv.name}} = {{ode_for(regime, sv).rhs}}
    }
    {% endfor %}
}
{% endfor %}

NET_RECEIVE(w, channel) {

    :printf("Received event with weight %f on channel %f at %f\n", w, channel, t)
    :printf("Received event at %f\n", t)

    INITIAL {
      : stop channel being set to 0 by default
    }

    if (flag == INIT) {
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
        WATCH ( {{oc.trigger.rhs}} )  {{(regime.name + '_' + oc.name + '_CONDITION_') | upper}}
    {% endfor %}
{% endfor %}
    } else if (flag == SPIKE) {
        :printf("Received spike with weight %f on channel %f at %f\n", w, channel, t)
{% for regime in componentclass.regimes %}
        if (regime == {{regime.name | upper}}) {
        printf("Current regime: {{regime.name | upper}} \n")
    {% for oe in regime.on_events %}
            if (channel == {{(regime.name + '_' + oe.name + '_EVENT_') | upper}}) {
                printf("  Resolved to channel {{regime_name + '-' + oe.name}}\n" )
        {% if weight_variables %}
                {{get_weight_variable}}({{channel}}, {{weight_variables}}) = w
        {% endif %}

        {% for sa in on_event.state_assignments %}
                {{sa.lhs}}  =  {{sa.neuron_rhs}}
        {% endfor %}

        {% for node in on_event.event_outputs %}
                {{as_expr}}(node)
        {% endfor %}
            }
    {% endfor %}
        }
{% endfor %}
    }

    : First Round of event filtering:
    : Pick up events emitted by WATCH Block.
    : Re-validate them against Conditions and Regime:
    : Retransmit the correct Transition ID

    else if (flag == 4000) {
        if(first_round_fired == 1) {

{% for regime in componentclass.regimes %}
        } else if( regime == {{regime.flag}} ) {
    {% for transition in regime.on_conditions %}
            if( {{transition.trigger.rhs}} ) {
                :printf("\nFirst Round Transition Filtering: Forwarding Event: {{transition.flag}} @ t=%f",t)
                net_send(0, {{transition.flag}} )
            }
    {% endfor %}
{% endfor %}
        }

        : Make sure that we only enter this block once
        first_round_fired = 1
    }

    : Second Round
{% for regime in componentclass.regimes %}
    {% for transition in regime.on_conditions %}
    else if (flag == {{transition.flag}}) {
        first_round_fired = 0
        :printf("\nt=%f In Regime {{regime.name}} Event With Flag: %f", t, flag )
        :printf("\nt=%f Changing Regime from {{regime.name}} to {{transition.target_regime.name}} via {{transition.flag}}", t )
        regime = {{transition.target_regime.flag}}

        {% for node in transition.event_outputs %}
        net_event(t)
        {% endfor %}

        {% for sa in transition.state_assignments %}
        {{sa.lhs}}  = {{sa.neuron_rhs}}
        {% endfor %}
    }
    {% endfor %}
{% endfor %}
}
