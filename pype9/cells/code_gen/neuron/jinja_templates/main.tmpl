:VERBATIM
:extern double nineml_gsl_normal(double, double);
:extern double nineml_gsl_uniform(double, double);
:extern double nineml_gsl_binomial(double, int);
:extern double nineml_gsl_exponential(double);
:extern double nineml_gsl_poisson(double);
:ENDVERBATIM

TITLE Spiking node generated from 9ML using PyPe9 version {{version}}

NEURON {
    POINT_PROCESS {{component.name}}
    RANGE regime

    :StateVariables:
{% for sv in componentclass.state_variables %}
    RANGE {{sv.name}}
{% endfor %}

    :Parameters
{% for p in componentclass.parameters %}
    RANGE {{p.name}}
{% endfor %}

    :Aliases
{% for alias in componentclass.aliases %}
    RANGE {{alias.lhs}}
{% endfor %}
}

CONSTANT {
    : IDs for regimes, events and conditions 

    : Basic events
    SPIKE = 0
    INIT = 1

    : Regime flags
{% for regime in componentclass.regimes %}
    {{regime.name | upper}} = {{componentclass.index_of(regime)}}
{% endfor %}

    : Event port flags
{% for port in componentclass.event_receive_ports %}
    {{port.name | upper}} = {{componentclass.index_of(port)}}
{% endfor %}

    : On-condition flags
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
    CONDITION_{{componentclass.index_of(oc)}}_ = {{componentclass.index_of(oc)}}
    {% endfor %}
{% endfor %}

}

INITIAL {
    : Initialise State Variables:
{% for sv in componentclass.state_variables %}
    {{sv.name}} = 0
{% endfor %}

    : Initialise Regime:
    {# This should come from the initial state, when we sort out that format #}
    regime = {{next(componentclass.regimes).name | upper}}

    : Initialise the NET_RECEIVE block:
    net_send(0, INIT)

    first_round_fired = 0
}

PARAMETER {
    : True parameters
{% for p in componentclass.parameters %}
    {{p.name}} = 0
{% endfor %}

    : Constants
{% for c in componentclass.constants %}
    {{c.name}} = {{c.value}} ({{c.units.name}})
{% endfor %}
}

STATE {
{% for sv in componentclass.state_variables %}
    {{sv.name}}
{% endfor %}
    first_round_fired
}

ASSIGNED {
    regime

{% for alias in componentclass.aliases %}
    {{alias.lhs}}
{% endfor %}

{% if weight_variables %}
{% for var in weight_variables.values %}
    {{var}}
{% endfor %}
{% endif %}
}

BREAKPOINT {
    :SOLVE states METHOD derivimplicit
    SOLVE states METHOD cnexp

{% for alias in componentclass.aliases %}
    {{alias.lhs}} = {{alias.rhs}}
{% endfor %}
}

DERIVATIVE states {
{% for sv in componentclass.state_variables %}
    {{sv.name}}' = _deriv_{{sv.name}}({{deriv_func_args(componentclass, sv.name)}}))
{% endfor %}
}

{% for sv in componentclass.state_variables %}
FUNCTION _deriv_{{sv.name}}({{deriv_func_args(componentclass, sv.name)}})) {
    {% for regime in componentclass.regimes %}
    if (regime == {{regime.name | upper}}) {
        _deriv_{{sv.name}} = {{ode_for(regime, sv).rhs}}
    }
    {% endfor %}
}
{% endfor %}

NET_RECEIVE(w, channel) {

    :printf("Received event with weight %f on channel %f at %f\n", w, channel, t)
    :printf("Received event at %f\n", t)

    INITIAL {
      : stop channel being set to 0 by default
    }

    if (flag == INIT) {
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
        WATCH ({{oc.trigger.rhs}})  CONDITION_{{componentclass.index_of(oc)}}_
    {% endfor %}
{% endfor %}
    } else if (flag == SPIKE) {
        :printf("Received spike with weight %f on channel %f at %f\n", w, channel, t)
{% for regime in componentclass.regimes %}
        if (regime == {{regime.name | upper}}) {
            printf("Current regime: {{regime.name}} \n")
    {% for oe in regime.on_events %}
            if (channel == {{oe.src_port_name | upper}}) {
                printf("  Resolved to channel {{regime.name + '-' + oe.src_port_name}}\n" )
        {% if weight_variables %}
                {{get_weight_variable}}({{channel}}, {{weight_variables}}) = w
        {% endif %}

        {% for sa in oe.state_assignments %}
                {{sa.lhs}}  =  {{sa.rhs}}
        {% endfor %}

        {% for node in oe.event_outputs %}
                {{as_expr}}(node)
        {% endfor %}
            }
    {% endfor %}
        }
{% endfor %}
    }

    : First Round of event filtering:
    : Pick up events emitted by WATCH Block.
    : Re-validate them against Conditions and Regime:
    : Retransmit the correct Transition ID

    else if (flag == 4000) {
        if(first_round_fired == 1) {

{% for regime in componentclass.regimes %}
        } else if (regime == {{regime.name | upper}}) {
    {% for oc in regime.on_conditions %}
            if( {{oc.trigger.rhs}} ) {
                :printf("\nFirst Round Transition Filtering: Forwarding Event: {{componentclass.index_of(oc)}} @ t=%f",t)
                net_send(0, CONDITION_{{componentclass.index_of(oc)}}_)
            }
    {% endfor %}
{% endfor %}
        }

        : Make sure that we only enter this block once
        first_round_fired = 1
    }

    : Second Round
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
    else if (flag == CONDITION_{{componentclass.index_of(oc)}}_) {
        first_round_fired = 0
        :printf("\nt=%f In Regime {{regime.name}} Event With Flag: %f", t, flag )
        :printf("\nt=%f Changing Regime from {{regime.name}} to {{oc.target_regime.name}} via {{componentclass.index_of(oc)}}", t )
        regime = {{oc.target_regime.name | upper}}

        {% for node in oc.event_outputs %}
        net_event(t)
        {% endfor %}

        {% for sa in oc.state_assignments %}
        {{sa.lhs}}  = {{sa.rhs}}
        {% endfor %}
    }
    {% endfor %}
{% endfor %}
}
