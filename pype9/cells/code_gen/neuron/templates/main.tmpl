{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}
:VERBATIM
:extern double nineml_gsl_normal(double, double);
:extern double nineml_gsl_uniform(double, double);
:extern double nineml_gsl_binomial(double, int);
:extern double nineml_gsl_exponential(double);
:extern double nineml_gsl_poisson(double);
:ENDVERBATIM

TITLE Spiking node generated from 9ML using PyPe9 version {{version}} at '{{timestamp}}'

NEURON {
    {%+ if is_subcomponent %}SUFFIX{% else %}POINT_PROCESS{% endif %} {{component_name}}
{% for port in componentclass.analog_send_ports if port.dimension == units.currentDensity or port.dimension == units.current %}
    {% set ion_species = port.annotations[PYPE9_NS][ION_SPECIES] %}
    {% if not ion_species or ion_species == NON_SPECIFIC_CURRENT %}
    NONSPECIFIC_CURRENT {{port.name}}
    {% else %}
    USEION {{ion_species}} WRITE {{ion_species}}i
    {% endif %}        
{% endfor %}
    : T
    RANGE regime_

    :StateVariables:
{% for sv in componentclass.state_variables %}
    RANGE {{sv.name}}
{% endfor %}

    :Parameters
{% for p in componentclass.parameters %}
    RANGE {{p.name}}
{% endfor %}

    :Ports
{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) if p.name != 'v' %}
    RANGE {{p.name}}
{% endfor %}

    :Aliases
{% for alias in chain(componentclass.aliases) %}
    RANGE {{alias.name}}
{% endfor %}
}

CONSTANT {
    : IDs for regimes, events and conditions 

    : Transition flags
    INIT = -1    
    ON_EVENT = 0

    : Regime ids
{% for regime in componentclass.regimes %}
    {{regime.name | upper}} = {{componentclass.index_of(regime)}}
{% endfor %}

    : Event port ids
{% for port in componentclass.event_receive_ports %}
    {{port.name | upper}} = {{componentclass.index_of(port)}}
{% endfor %}

}

INITIAL {
    : Initialise State Variables:
{% for sv in componentclass.state_variables %}
    {{sv.name}} = 0
{% endfor %}

    : Initialise Regime:
    {# This should come from the initial state, when we sort out that format #}
    regime_ = {{next(componentclass.regimes).name | upper}}

    : Initialise the NET_RECEIVE block by sending appropriate flag to itself
    net_send(0, INIT)

}

PARAMETER {
    : True parameters
{% for p in componentclass.parameters %}
    {{p.name}} = 0
{% endfor %}

    : Constants
{% for c in componentclass.constants %}
    {{c.name}} = {{c.value}} ({{c.units.name}})
{% endfor %}
}

STATE {
{% for sv in componentclass.state_variables if sv.name != 'v' %}
    {{sv.name}}
{% endfor %}
}



ASSIGNED {
    : Internal flags
    regime_
    found_transition_
{% if not is_subcomponent %}
   
    : Membrane voltage
    v (mV)
{% endif %}

    : Aliases
{% for alias in componentclass.aliases %}
    {{alias.name}}
{% endfor %}
}

BREAKPOINT {
    SOLVE states METHOD {{ode_solver}}
{% set output_analog_exprs = componentclass.required_for(componentclass.all_output_analogs()).expressions + list(componentclass.all_output_analogs()) %}
{% for expr in output_analog_exprs %}
    {{expr.lhs}} = {{expr.rhs_cstr}}
{% endfor %}
{% for expr in componentclass.required_for(componentclass.all_time_derivatives()).expressions if expr not in output_analog_exprs %}
    {{expr.lhs}} = {{expr.rhs_cstr}}
{% endfor %}
}

DERIVATIVE states {
{% for sv in componentclass.state_variables if sv.name not in componentclass.annotations[PYPE9_NS][NO_TIME_DERIVS] %}
    {{sv.name}}' = deriv_{{sv.name}}({{componentclass.required_for(componentclass.all_time_derivatives(sv)).state_variable_names | join(', ')}})
{% endfor %}
}

{% for sv in componentclass.state_variables if sv.name not in componentclass.annotations[PYPE9_NS][NO_TIME_DERIVS] %}
FUNCTION deriv_{{sv.name}}({{componentclass.required_for(componentclass.all_time_derivatives(sv)).state_variable_names | join(', ')}}) {
    {% for regime in componentclass.regimes  if sv.name in regime._time_derivatives %}
    {{elseif(loop.first)}} (regime_ == {{regime.name | upper}}) {
        deriv_{{sv.name}} = {{regime.time_derivative(sv.name).rhs_cstr}}
    {{endif(loop.last)}}
    {% endfor %}
}
{% endfor %}

NET_RECEIVE(weight_, channel) {
    INITIAL {
      : stop channel being set to 0 by default
    }
    found_transition_ = -1
    if (flag == INIT) {
        : Set up required watch statements
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
        WATCH ({{oc.trigger.rhs_cstr}}) {{componentclass.index_of(oc.trigger.rhs, key='TriggerRHS') + 1}}  : Watch trigger of on-condition and send appropriate flag
    {% endfor %}
{% endfor %}
{% for regime in componentclass.regimes %}
    } else if (regime_ == {{regime.name | upper}}) {
    {% for trans in regime.transitions %}
        {% if hasattr(trans, 'trigger') %}
        if (flag == {{componentclass.index_of(trans.trigger.rhs, key='TriggerRHS') + 1}}) {  : Condition '{{trans.trigger.rhs_str}}'
        {% else %}
        if (flag == ON_EVENT && channel == {{trans.src_port_name | upper}}) {
        {% endif %}      
            : Required aliases
        {% for expr in componentclass.required_for(trans.state_assignments).expressions %}
            {{expr.lhs}} = {{expr.rhs_cstr}}
        {% endfor %}

            : State assignments
        {% for sa in trans.state_assignments %}
            {{sa.lhs}} = {{sa.rhs_cstr}}
        {% endfor %}

            : Output events
        {% for node in trans.output_events %}
            net_event(t)  : FIXME: Need to specify which output port this is
        {% endfor %}
        
            : Regime transition
            if (found_transition_ == -1) {
                found_transition_ = flag
            } else {
                printf("WARNING!! Found multiple transitions %f and %f at a single timestep", found_transition_, flag)
            }
            regime_ = {{trans.target_regime.name | upper}}
        }
    {% endfor %}
{% endfor %}
    } else {
        printf("ERROR! Unrecognised regime %f", regime_)
    }
}
