{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}
:VERBATIM
:extern double nineml_gsl_normal(double, double);
:extern double nineml_gsl_uniform(double, double);
:extern double nineml_gsl_binomial(double, int);
:extern double nineml_gsl_exponential(double);
:extern double nineml_gsl_poisson(double);
:ENDVERBATIM

TITLE Spiking node generated from 9ML using PyPe9 version {{version}} at '{{timestamp}}'

NEURON {
    {%+ if is_subcomponent %}SUFFIX{% else %}POINT_PROCESS{% endif %} {{component_name}}
{% for port in componentclass.analog_send_ports if port.dimension == units.currentDensity or port.dimension == units.current %}
    {% set ion_species = port.annotations[PYPE9_NS][ION_SPECIES] %}
    {% if not ion_species or ion_species == NON_SPECIFIC_CURRENT %}
    NONSPECIFIC_CURRENT {{port.name}}
    {% else %}
    USEION {{ion_species}} WRITE {{ion_species}}i
    {% endif %}        
{% endfor %}
    : T
    RANGE regime_

    :StateVariables:
{% for sv in componentclass.state_variables %}
    RANGE {{sv.name}}
{% endfor %}

    :Parameters
{% for p in componentclass.parameters %}
    RANGE {{p.name}}
{% endfor %}

    :Ports
{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) if p.name != 'v' %}
    RANGE {{p.name}}
{% endfor %}

    :Aliases
{% for alias in chain(componentclass.aliases) %}
    RANGE {{alias.name}}
{% endfor %}
}

CONSTANT {
    : IDs for regimes, events and conditions 

    : Transition flags
    ON_EVENT = 0
    ON_CONDITION = 1
    INIT = 2

    : Regime ids
{% for regime in componentclass.regimes %}
    {{regime.name | upper}} = {{componentclass.index_of(regime)}}
{% endfor %}

    : Event port ids
{% for port in componentclass.event_receive_ports %}
    {{port.name | upper}} = {{componentclass.index_of(port)}}
{% endfor %}

}

INITIAL {
    : Initialise State Variables:
{% for sv in componentclass.state_variables %}
    {{sv.name}} = 0
{% endfor %}

    : Initialise Regime:
    {# This should come from the initial state, when we sort out that format #}
    regime_ = {{next(componentclass.regimes).name | upper}}

    : Initialise the NET_RECEIVE block:
    net_send(0, INIT)
    
    : Active/inactive conditions (conditions transitions are only valid on 
    : triggered from False->True) so check to see if start off False
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
    {{regime.name | lower}}_cond{{componentclass.index_of(oc, key=regime)}}_active = ({{oc.trigger.reactivate_condition.rhs_cstr.replace('=', '')}})
    {% endfor %}
{% endfor %}

}

PARAMETER {
    : True parameters
{% for p in componentclass.parameters %}
    {{p.name}} = 0
{% endfor %}

    : Constants
{% for c in componentclass.constants %}
    {{c.name}} = {{c.value}} ({{c.units.name}})
{% endfor %}
}

STATE {
{% for sv in componentclass.state_variables if sv.name != 'v' %}
    {{sv.name}}
{% endfor %}
}



ASSIGNED {
    : Internal flags
    regime_
    regime_changed_
    
    : Active/inactive conditions (conditions transitions are only valid on 
    : triggered from False->True)
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
    {{regime.name | lower}}_cond{{componentclass.index_of(oc, key=regime)}}_active
    {% endfor %}
{% endfor %}

    : Weight variables
{% if weight_variables %}
    {% for var in weight_variables.values %}
    {{var}}
    {% endfor %}
{% endif %}

{% if not is_subcomponent %}   
    : Membrane voltage
    v (mV)
{% endif %}

    : Aliases
{% for alias in componentclass.aliases %}
    {{alias.name}}
{% endfor %}
}

BREAKPOINT {
    SOLVE states METHOD {{ode_solver}}
{% for expr in set(chain(componentclass.required_for(componentclass.all_time_derivatives()).expressions,
                         componentclass.required_for(componentclass.all_output_analogs()).expressions,
                         componentclass.all_output_analogs()))%}
    {{expr.lhs}} = {{expr.rhs_cstr}}
{% endfor %}
}

DERIVATIVE states {
{% for sv in componentclass.state_variables if sv.name != 'v' %}
    {{sv.name}}' = deriv_{{sv.name}}({{componentclass.required_for(componentclass.all_time_derivatives(sv)).state_variable_names | join(', ')}})
{% endfor %}
}

{% for sv in componentclass.state_variables if sv.name != 'v' %}
FUNCTION deriv_{{sv.name}}({{componentclass.required_for(componentclass.all_time_derivatives(sv)).state_variable_names | join(', ')}}) {
    {% for regime in componentclass.regimes  if sv.name in regime._time_derivatives %}
    {{elseif(loop.first)}} (regime_ == {{regime.name | upper}}) {
        deriv_{{sv.name}} = {{regime.time_derivative(sv.name).rhs_cstr}}
    {{endif(loop.last)}}
    {% endfor %}
}
{% endfor %}

NET_RECEIVE(weight_, channel) {
    INITIAL {
      : stop channel being set to 0 by default
    }
    if (flag == INIT) {
{% for regime in componentclass.regimes %}
    {% for oc in regime.on_conditions %}
        WATCH ({{oc.trigger.rhs_cstr}}) 1  : Trigger an on-condition
        WATCH ({{oc.trigger.reactivate_condition.rhs_cstr.replace('=', '')}}) 1  : Reactivate trigger
    {% endfor %}
{% endfor %}
    } else if (flag == ON_EVENT) {
{% for regime in componentclass.regimes %}
        {{elseif(loop.first)}} (regime_ == {{regime.name | upper}}) {
    {% for oe in regime.on_events %}
            {{elseif(loop.first)}} (channel == {{oe.src_port_name | upper}}) {
        {% if weight_variables %}
                {{get_weight_variable}}({{channel}}, {{weight_variables}}) = w
        {% endif %}        
                : Expressions
        {% for expr in componentclass.required_for(oe.state_assignments).expressions %}
            {% if hasasttr(expr, 'pieces') %}  {# Is a Piecewise statement #}
                {% for piece in expr.pieces %}
                {{elseif(loop.first)}} ({{expr.condition}})
                    {{expr_name}} = {{piece.rhs_cstr}}
                {% endfor %}
                else
                    {{expr_name}} = {{expr.otherwise.rhs_cstr}} 
            {% else %}
                {{expr.lhs}} = {{expr.rhs_cstr}}
            {% endif %}
        {% endfor %}
        {% for sa in oe.state_assignments %}
                {{sa.lhs}} = {{sa.rhs_cstr}}
        {% endfor %}
        {% for node in oe.output_events %}
                {{as_expr}}(node)
        {% endfor %}
            }
    {% endfor %}
{% endfor %}
        }
    } else if (flag == ON_CONDITION) {
        : Reactivate triggers that have passed below their thresholds
{% for oc in componentclass.all_on_conditions() %}
        if ({{oc.trigger.reactivate_condition.rhs_cstr}}) {
            {{oc.source_regime.name | lower}}_cond{{componentclass.index_of(oc, key=oc.source_regime)}}_active = 1
        }
{% endfor %}
        : Pick up untriaged on-conditions emitted by WATCH Block and
        : re-validate them against Conditions and Regime:
        regime_changed_ = 0
{% for regime in componentclass.regimes %}
        {{elseif(loop.first)}} (regime_ == {{regime.name | upper}}) {
    {% for oc in regime.on_conditions %}
            if (({{oc.trigger.rhs_cstr}}) && {{regime.name | lower}}_cond{{componentclass.index_of(oc, key=regime)}}_active) {
	            {% if oc.target_regime != regime %}
                if (!regime_changed_) {
                    regime_ = {{oc.target_regime.name | upper}}
                    regime_changed_ = 1
                } else {
                    printf("Warning! Simulataneous regime changes requested, ignoring change from '{{regime.name}}' to '{{oc.target_regime.name}}'.")
                }
	            {% endif %}
	        {% for node in oc.output_events %}
                net_event(t)
	        {% endfor %}
	        {% for sa in oc.state_assignments %}
                {{sa.lhs}} = {{sa.rhs_cstr}}
	        {% endfor %}
                {{regime.name | lower}}_cond{{componentclass.index_of(oc, key=regime)}}_active = 0  
            }
    {% endfor %}
{% endfor %}
        }
    }
}
