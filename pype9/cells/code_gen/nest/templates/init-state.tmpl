{# This template adds State class constructors and assignments

   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//-------------------------------------------------//
// This section was generated from init-state.tmpl //
//-------------------------------------------------//
/**
 * Construct state from parameters.
 */
{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;
{% if (ode_solver == "gsl") %}
    r_ = 0;
{% endif %}

{# Initialise the state #}
{# FIXME: need to add initial state here #}
{% for sv in componentclass.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{# Solve steady-state if required #}
{# This needs some thinking out, not implemented yet
{% if (ss_solver  == "kinsol") %}
    N_Vector {{SSvector}};
    ssvect = N_VNew_Serial({{steadyStateSize}});
    fsolve ({{component_name}}_steadystate, {{steadyStateSize}}, {{SSvector}},
          (void *)&p,  "{{component_name}}");
    {% for name in rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = ITEM({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    N_VDestroy_Serial ({{SSvector}});
{% elif stead_state %}
    gsl_vector *{{SSvector}};
    {{SSvector}} = gsl_vector_alloc ({{steadyStateSize}});
    fsolve ({{component_name}}_steadystate, {{steadyStateSize}}, {{SSvector}},
           (void *)&p, "{{component_name}}");
    {% for name in init.rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = gsl_vector_get({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    gsl_vector_free ({{SSvector}});
    {% for eq in init.reactionEqDefs %}
    {{eq}}
    {% endfor %}
    {% for eq in currentEqDefs %}
    {{eq}}
    {% endfor %}
    {% if ("v" in steadyStateIndexMap) %}
    y_[{{steadyStateIndexMap["v"]}}] =  v;
    {% endif %}
{% endif %}
#}
}

/**
 * Copy constructor for State class
 */
{{component_name}}::State_::State_(const State_& s) {

{% if (ode_solver == "gsl") %}
  r_ = s.r_;
{% endif %}

  for (int i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
      y_[i] = s.y_[i];
}

/**
 * Assignment of a State from another State
 */
{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {

{% if (ode_solver == "gsl") %}
  r_ = s.r_;
{% endif %}

  assert(this != &s);
  for (size_t i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
{% if (ode_solver == "gsl") %}
    V_.U_old_ = S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX];
    {#{% if refractory_period %}
    V_.RefractoryCounts_ = nest::Time(nest::Time::ms(P_.t_ref)).get_steps();
    {% else %}#}
    V_.RefractoryCounts_ = 0;
    {#{% endif %}#}
{% endif %}
}
// ------------------- init-state.tmpl ------------------------//
