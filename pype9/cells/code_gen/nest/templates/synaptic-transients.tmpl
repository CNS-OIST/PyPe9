{#
   NEST synaptic event transient template 

   This template defines C++ methods of the form:

   int ModelName::synapticEvent_transients (long_t lag)

   These methods update the synaptic states when a spike is received.
   They are invoked by the event handling portion of the update method,
   which is generated by template "NEST-solver-events.tmpl".

   Template variables are:

   - ModelName: the name of the current system
   - synapticEventDefs - a list of synaptic event objects that have the following fields:

     - pscName - descriptive name (label) of the post-synaptic conductance component
     - pscId - unique identifier of the post-synaptic conductance component
     - localVars - local variables used in the state update equations
     - eventVarEqDef - the equation that assigns the event variable its value
       (currently, this is the equation that reads the synaptic weight from the event queue)
     - eventVar - the name of the variable the receives the event argument (e.g. weight)
     - externalEventEqDef - the equations that assigns values to any imported quantities, e.g. voltage
     - transientEventEqDefs - the equations that update the synaptic states
   
   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//----------------------------------------------------------//
// This section was generated from synaptic-transients.tmpl //
//----------------------------------------------------------//

{% for regime in componentclass.regimes %}
    {% for oe in regime.on_events %}
inline void {{component_name}}::{{oe.src_port_name}}_event_in_{{regime.name}}(long_t lag) {
    
    // Map states used in dynamics to current namespace
        {% for sv in componentclass.state_variables %}
    const double_t {{sv.name}} = S_.y_[{{component_name}}::State_::{{sv.name}}_INDEX];
        {% endfor %}
        
    {% set dp = componentclass.required_for(oe.state_assignments) %}
    
    // Map parameters used in dynamics to current namespace
        {% for param in dp.parameters %}
    const double_t {{param.name}} = P_.{{param.name}};
        {% endfor %}

    // Map port buffers to current namespace
        {% for port in dp.ports %}
    const double_t {{port.name}} = B_.{{port.name}}_value;
        {% endfor %}

    // Add constants
    {% for const in dp.constants %}
        {% set conv = componentclass.unit_conversion_factor(const.units) %}
        {% set conv_value = conv[0] * const.value + conv[1] %}
    const static double_t {{const.name}} = {{conv_value}};  // {{const.value}} ({{const.units.name}})
    {% endfor %}
    
    // Add random variables
    {% for rv in dp.random_variables %}
    const double_t {{rv.name}} = {{get_random_function(rv)}}
    {% endfor %}
   
    // Evaluate aliases used in differential equations
        {% for expr in dp.expressions %}
            {% if hasasttr(expr, 'pieces') %}  {# Is a Piecewise statement #}
    const double_t {{expr.name}};
                {% for piece in expr.pieces %}
    {% if not loop.first %}else {% endif -%}
    if ({{expr.condition}})
        {{expr_name}} = {{expr.rhs_cstr}};
                {%- endfor %}
    else
        {{expr_name}} = {{expr.otherwise.rhs_cstr}}; 
            {% else %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
            {% endif %}
        {% endfor %}

    // Evaluate differential equations
        {% for assign in oe.state_assignments %}
    S_.y_[{{component_name}}::State_::{{assign.lhs}}_INDEX] = {{assign.rhs_cstr}};
        {% endfor %}
}
    {% endfor %}
{% endfor %}
//-------------- synaptic-transients.tmpl --------------//