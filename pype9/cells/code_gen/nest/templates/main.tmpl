{# 
   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"



/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in componentclass.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
{# FIXME: Need to translate v->V_m
{% if ("v" in stateIndexMap) %}
    insert_(names::V_m, &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::V>);
{% endif %}
#}
  }
}


/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

{% for regime in componentclass.regimes %}
    {%- if ode_solver in ('cvode', 'ida') -%}
extern "C" int {{component_name}}_{{regime.name}}_dynamics(double t_, N_Vector y_, N_Vector f_, void* pnode_) {
    {% else %}
extern "C" int {{component_name}}_{{regime.name}}_dynamics(double t_, const double y_[], double f_[], void* pnode_) {
    {% endif %}

    // Get a reference to the model
    assert(pnode_);
    const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));

    // Map states used in dynamics to current namespace
    {% for state in componentclass.state_variables %}
    const double_t {{state.name}} = ITEM(y_, {{component_name}}::State_::{{state.name}}_INDEX);
    {% endfor %}

    {% set dp = componentclass.required_for(regime.time_derivatives) %}

    // Map parameters used in dynamics to current namespace
    {% for param in dp.parameters %}
    const double_t {{param.name}} = node_.P_.{{param.name}};
    {% endfor %}

    // Map port buffers to current namespace
    {% for port in dp.ports %}
    const double_t {{port.name}} = node_.B_.{{port.name}}_value;
    {% endfor %}

    // Add constants
    {% for const in dp.constants %}
    const static double_t {{const.name}} = {{const.value}}; // ({{const.units.name}})
    {% endfor %}

    // Evaluate aliases used in differential equations
    {% for expr in dp.expressions %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
    {% endfor %}

    // Evaluate differential equations
    {% for td in regime.time_derivatives %}
    ITEM(f_, {{component_name}}::State_::{{td.dependent_variable}}_INDEX) = {{td.rhs_cstr}};
    {% endfor %}

    {% if ode_solver == 'gsl' %}
    return GSL_SUCCESS;
    {% else %}
    return 0;
    {% endif %}
}
{% endfor %}


{% if ode_solver == "ida" %}
/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/
    {% for regime in componentclass.regimes %}
extern "C" int {{component_name}}_{{regime.name}}_residual (double t, N_Vector y, N_Vector yp, N_Vector f, void* pnode) {
    int status;

    // cast the node ptr to an object of the proper type
    assert(pnode);
    {{component_name}} & vnode =  *(reinterpret_cast<{{component_name}}*>(pnode));

    N_Vector y1 = vnode.B_.y1;

    status = {{component_name}}_{{regime.name}}_dynamics (t, y, y1, pnode);

        {% for i in xrange(componentclass.num_state_variables) %}
    ITEM(f, {{i}}) = ITEM(y1, {{i}}) - ITEM(yp, {{i}});
        {% endfor %}

    return status;
    {% endfor %}
}
{% endif %}


/***********************
 * Steady-sate solvers *
 ***********************/

{% if ss_solver == "kinsol" %}
  int fsolve (KINSysFn f, int N, N_Vector fval, void *user_data,
              std::string name) {
      int status;
      N_Vector u0, sc;
      void *kmem;

      u0 = N_VNew_Serial(N);
      N_VConst_Serial(0.0,u0);
      N_VConst_Serial(0.0,fval);

      sc = N_VNew_Serial(N);
      N_VConst_Serial(1.0,sc);

      kmem = KINCreate();

      status = KINSetUserData (kmem, user_data);
      if (check_flag (&status, "KinSetUserData", 1))
        throw KINSolverFailure (name, status);

      status = KINInit (kmem, f, u0);
      if (check_flag (&status, "KinInit", 1))
        throw KINSolverFailure (name, status);

      status = KINDense (kmem, N);
      if (check_flag (&status, "KinDense", 1))
        throw KINSolverFailure (name, status);

      status = KINSol (kmem, fval, KIN_NONE, sc, sc);
      if (check_flag (&status, "KINSol", 1))
        throw KINSolverFailure (name, status);

      N_VDestroy_Serial(sc);
      N_VDestroy_Serial(u0);

      KINFree (&kmem);

      return 0;
  }

  extern "C" int {{component_name}}_steadystate (N_Vector u, N_Vector f, void* pnode) {
     return 0;
  }
{% elif ss_solver == "gsl" %}
  int fsolve (int (*fss)(const gsl_vector *, void *user_data, gsl_vector *),
              int N, gsl_vector *fval, void *user_data, std::string name) {

      const gsl_multiroot_fsolver_type * T = gsl_multiroot_fsolver_hybrid;
      gsl_multiroot_fsolver * s = gsl_multiroot_fsolver_alloc (T, N);
      gsl_multiroot_function f = {fss, N, user_data};

      int status, iter;
      gsl_vector *x = gsl_vector_alloc (N);
      for (int i = 0; i < N; i++)
         gsl_vector_set (x, i, 0.0);
      gsl_multiroot_fsolver_set (s, &f, x);

      iter = 0;
      do {
         iter++;
         status = gsl_multiroot_fsolver_iterate (s);
         if ((status == GSL_EBADFUNC) || (status == GSL_ENOPROG))
            throw nest::GSLSolverFailure(name, status);
         status =  gsl_multiroot_test_residual (s->f, 1e-7);
      } while (status == GSL_CONTINUE && iter < 1000);

      for (int i = 0; i < N; i++)
         gsl_vector_set (fval, i, gsl_vector_get (s->x, i));

      gsl_vector_free (x);
      gsl_multiroot_fsolver_free (s);

      return 0;
  }
  
  extern "C" int {{component_name}}_steadystate (const gsl_vector *u, void *pnode, gsl_vector *f) {
    return 0;
  }  
{% endif %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}


{% if ode_solver == "gsl" %}
/*******************************************
 * Diagonal Jacobian approximation for GSL *
 *******************************************/

    {% for regime in componentclass.regimes %}
/** Diagonal Jacobian approximation (for GSL): (f(s+.01) - f(s))/.001 */
extern "C" int {{component_name}}_{{regime.name}}_jacobian (double t, const double y[], double *dfdy, double dfdt[], void* pnode) {
  // cast the node ptr to an object of the proper type
  assert(pnode);
  const {{component_name}} & node = *(reinterpret_cast<{{component_name}}*>(pnode));
  {{component_name}} & vnode =  *(reinterpret_cast<{{component_name}}*>(pnode));

  // state is a reference to the model state
  struct {{component_name}}::Buffers_ *b;
  b = &(vnode.B_);

  for (int i = 0; i < b->N; i++)
    b->u[i] = y[i] + 0.01;

  {{component_name}}_{{regime.name}}_dynamics(t, b->u, b->jac, pnode);
  for (int i = 0; i < b->N; i++)
    dfdt[i*b->N + i] = (b->jac[i] - dfdy[i]) / .001;
  return 0;
}
    {% endfor %}
{% endif %}


/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_():
{% for i, param in enumerate(componentclass.parameters) %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{% for param in componentclass.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
}


/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;
{% if ode_solver == "gsl" %}
    r_ = 0;
{% endif %}

{# Initialise the state #}
{# FIXME: need to add initial state here #}
{% for sv in componentclass.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{# Solve steady-state if required #}
{# This needs some thinking out, not implemented yet
{% if (ss_solver  == "kinsol") %}
    N_Vector {{SSvector}};
    ssvect = N_VNew_Serial({{steadyStateSize}});
    fsolve ({{component_name}}_steadystate, {{steadyStateSize}}, {{SSvector}},
          (void *)&p,  "{{component_name}}");
    {% for name in rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = ITEM({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    N_VDestroy_Serial ({{SSvector}});
{% elif stead_state %}
    gsl_vector *{{SSvector}};
    {{SSvector}} = gsl_vector_alloc ({{steadyStateSize}});
    fsolve ({{component_name}}_steadystate, {{steadyStateSize}}, {{SSvector}},
           (void *)&p, "{{component_name}}");
    {% for name in init.rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = gsl_vector_get({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    gsl_vector_free ({{SSvector}});
    {% for eq in init.reactionEqDefs %}
    {{eq}}
    {% endfor %}
    {% for eq in currentEqDefs %}
    {{eq}}
    {% endfor %}
    {% if ("v" in steadyStateIndexMap) %}
    y_[{{steadyStateIndexMap["v"]}}] =  v;
    {% endif %}
{% endif %}
#}
}


/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) {

{% if ode_solver == "gsl" %}
  r_ = s.r_;
{% endif %}

  for (int i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
      y_[i] = s.y_[i];
}


/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {

{% if ode_solver == "gsl" %}
  r_ = s.r_;
{% endif %}

  assert(this != &s);
  for (size_t i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
{% if ode_solver == "gsl" %}
    V_.U_old_ = S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX];
    {#{% if refractory_period %}
    V_.RefractoryCounts_ = nest::Time(nest::Time::ms(P_.t_ref)).get_steps();
    {% else %}#}
    V_.RefractoryCounts_ = 0;
    {#{% endif %}#}
{% endif %}
}


/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in componentclass.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in componentclass.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {

    // Get states from internal variables
{% for i, sv in enumerate(componentclass.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
{# FIXME: Need to include special handling of v->V_m
{% if ("v" in stateIndexMap) %}
    def<double_t>(d_, names::V_m, y_[{{stateIndexMap["v"]}}]);
{% endif %}
#}

}

void {{component_name}}::State_::set (const DictionaryDatum &d_, const Parameters_&) {

    // Set internal state variables from dictionary values
{% for i, sv in enumerate(componentclass.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
{# FIXME: Need to include special handling of v->V_m
{% if ("v" in stateIndexMap) %}
   updateValue<double_t>(d_, names::V_m, y_[{{stateIndexMap["v"]}}]);
{% endif %}
#}

}


/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n),
{% if ode_solver in ("cvode", "ida") %}
      sys_(0),
{% elif ode_solver == "gsl" %}
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0),
{%- endif %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n),
{% if ode_solver in ("cvode", "ida") %}
      sys_(0),
{% elif ode_solver == "gsl" %}
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0),
{%- endif %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in componentclass.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;

{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

{% include "init-solver.tmpl" %}
}


/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {
    recordablesMap_.create();
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_);
}


/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
{% if ode_solver == "cvode" %}
    if ( B_.sys_ ) {
        // Free y vector
        N_VDestroy_Serial(B_.y);

        // Free integrator memory
        if (B_.sys_ != NULL) {
            CVodeFree(&B_.sys_);
            B_.sys_ = NULL;
        }
    }
{% elif ode_solver == "ida" %}
    if ( B_.sys_ ) {
        // Free y vector
        N_VDestroy_Serial(B_.y);
        N_VDestroy_Serial(B_.yp);

        // Free integrator memory
        if (B_.sys_ != NULL) {
            IDAFree(&B_.sys_);
            B_.sys_ = NULL;
        }
    }
{% elif ode_solver == "gsl" %}
    // GSL structs only allocated by init_nodes_(),
    // so we need to protect destruction
    if ( B_.s_ != NULL)
        gsl_odeiv2_step_free (B_.s_);
    if ( B_.c_ != NULL)
        gsl_odeiv2_control_free (B_.c_);
    if ( B_.e_ != NULL)
        gsl_odeiv2_evolve_free (B_.e_);
    if ( B_.u != NULL)
        free (B_.u);
    if ( B_.jac != NULL)
        free (B_.jac);
{% endif %}
}



/********************************************************
 * Trigger condition for regime changes and event outs. *
 ********************************************************/

{% if ode_solver in ('cvode', 'ida') %}
extern "C" int {{component_name}}_trigger (double t, N_Vector y,{% if ode_solver == 'ida' %} N_Vector yp,{% endif %} double *g, void* pnode) {
    double v, vt; v = -1.0; vt = 0.0;

    // S is shorthand for the type that describes the model state
    typedef {{component_name}}::State_ S;

    // cast the node ptr to an object of the proper type
    assert(pnode);
    const {{component_name}} & node =  *(reinterpret_cast<{{component_name}}*>(pnode));

    // params is a reference to the model parameters
    const struct {{component_name}}::Parameters_ *params;
    params = &(node.P_);

    // state is a reference to the model state
    const struct {{component_name}}::State_ *state;
    state = &(node.S_);

    {% if v_threshold %}
    v = ITEM(y, {{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX);
    g[0] = v - params->{{v_threshold}};
    {% else %}
    g[0] = -1.0;
    {% endif %}

    return 0;
}
{% elif ode_solver == 'gsl' %}
    // Trigger is hard coded as V_m > V_t, if V_t is present, at the moment.
{% endif %}



/********************************************************
 * OnEvent condition for regime changes and event outs. *
 ********************************************************/

{% for regime in componentclass.regimes %}
    {% for oe in regime.on_events %}
inline void {{component_name}}::{{oe.src_port_name}}_event_in_{{regime.name}}(nest::long_t lag) {

    // Map states used in dynamics to current namespace
        {% for sv in componentclass.state_variables %}
    const double_t {{sv.name}} = S_.y_[{{component_name}}::State_::{{sv.name}}_INDEX];
        {% endfor %}

    {% set dp = componentclass.required_for(oe.state_assignments) %}

    // Map parameters used in dynamics to current namespace
        {% for param in dp.parameters %}
    const double_t {{param.name}} = P_.{{param.name}};
        {% endfor %}

    // Map port buffers to current namespace
        {% for port in dp.ports %}
    const double_t {{port.name}} = B_.{{port.name}}_value;
        {% endfor %}

    // Add constants
    {% for const in dp.constants %}
        {% set conv = componentclass.unit_conversion_factor(const.units) %}
        {% set conv_value = conv[0] * const.value + conv[1] %}
    const static double_t {{const.name}} = {{conv_value}};  // {{const.value}} ({{const.units.name}})
    {% endfor %}

    // Add random variables
    {% for rv in dp.random_variables %}
    const double_t {{rv.name}} = {{get_random_function(rv)}}
    {% endfor %}

    // Evaluate aliases used in differential equations
        {% for expr in dp.expressions %}
            {% if hasasttr(expr, 'pieces') %}  {# Is a Piecewise statement #}
    const double_t {{expr.name}};
                {% for piece in expr.pieces %}
    {% if not loop.first %}else {% endif -%}
    if ({{expr.condition}})
        {{expr_name}} = {{expr.rhs_cstr}};
                {%- endfor %}
    else
        {{expr_name}} = {{expr.otherwise.rhs_cstr}};
            {% else %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
            {% endif %}
        {% endfor %}

    // Evaluate differential equations
        {% for assign in oe.state_assignments %}
    S_.y_[{{component_name}}::State_::{{assign.lhs}}_INDEX] = {{assign.rhs_cstr}};
        {% endfor %}
}
    {% endfor %}
{% endfor %}



/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);
    
    nest::long_t current_steps = origin.get_steps();
    
{# to remove    
{% if ode_solver in ('cvode', 'ida') %} 
    int N = NV_LENGTH_S (B_.y);
{% else %}
    int N = S_.N  // Size of the state vector
{% endif %}
#}

{% if ode_solver == 'euler' %}
    double f_[{{component_name}}::State_::STATE_VEC_SIZE_];  // Vector to hold the time derivatives
{% endif %}    
  
    for (nest::long_t lag = from; lag < to; ++lag) {
        double dt = nest::Time::get_resolution().get_ms();
        double tt = 0.0;

{% if ode_solver in ('cvode', 'ida') %}
    {% if ode_solver == 'cvode' %}
        {% set abbrev = 'CV' %}
        {% set prefix = 'CVode' %}
        {% set solver = 'CVode' %}
    {% else %}
        {% set abbrev = 'IDA' %}
        {% set prefix = 'IDA' %}
        {% set solver = 'IDASolve' %}
    {% endif %}
        double tout = (current_steps+lag) * dt;

        // adaptive step integration
        while (tt < tout) {
            const int status = {{solver}}(B_.sys_, tout, {% if ode_solver == 'cvode' %}B_.y, &tt{% elif ode_solver == 'ida' %}&tt, B_.y, B_.yp{% endif %}, {{abbrev}}_NORMAL);
            switch (status) {
                case {{abbrev}}_SUCCESS:      continue;
                case {{abbrev}}_ROOT_RETURN: {
                    set_spiketime(nest::Time::ms(tt));
                    nest::SpikeEvent se;
                    // Copy solver state to NEST state
                    for (int i = 0; i < {{component_name}}::State_::STATE_VEC_SIZE_; i++)
                        S_.y_[i] = ITEM(B_.y,i);
                    network()->send(*this, se, lag);
                    adjust_zero_crossings(B_.y, {{abs_tolerance}});
                    continue;
                }
                case {{abbrev}}_TSTOP_RETURN: break;
                default:
                    throw {{prefix}}SolverFailure (get_name(), 0);
            }
        }

        // Copy items from CVODE/IDA vector to NEST state array.
        for (int i = 0; i < {{component_name}}::STATE_VEC_SIZE_; i++)
           S_.y_[i] = ITEM(B_.y, i);
{% elif ode_solver == "gsl" %}
        V_.U_old_ = S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX];

        while (tt < dt) {
          const int status =  gsl_odeiv2_evolve_apply(B_.e_, B_.c_, B_.s_,
                                                      &B_.sys_, // system of ODE
                                                      &tt, // from t...
                                                      dt, // ...to t= t + dt
                                                      &B_.IntegrationStep_, // integration window (written on!)
                                                      S_.y_); // neuron state
          if (status != GSL_SUCCESS)
            throw nest::GSLSolverFailure(get_name(), status);
        }

        // Check threshold if not refractory and emit spike if crossed
        if ( S_.r_ > 0 )
           S_.r_--;
        {# FIXME: This threshold crossing should be handled by regimes #}
        else if (S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX] >= {{v_threshold}} &&
                 V_.U_old_ > S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX]) {
            S_.r_ = V_.RefractoryCounts_;
            set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
            nest::SpikeEvent se;
            network()->send(*this, se, lag);
        }
{% elif ode_solver == 'euler' %}
        // Calculate time derivatives
        {{component_name}}_{{default_regime}}_dynamics(tt, S_.y_, f_, this);
        for (int i = 0; i < {{component_name}}::State_::STATE_VEC_SIZE_; ++i)
           S_.y_[i] += f_[i] * dt;
{% endif %}

        // Event handling (still needs to handle events that arrive in the same
        // timestep.
        int num_events = 0;
{% if componentclass.num_regimes > 1 %}
    int transition = 0;
{% endif %}
{% for regime in componentclass.regimes %}
        {%+ if not loop.first %}} else {% endif %}if (B_.current_regime == {{regime.name}}_REGIME) {
    {% for oe in regime.on_events %}
            {%+ if not loop.first %}} else {% endif %}if (B_.{{oe.src_port_name}}_event_port.get_value(lag)) {
        {% if oe.target_regime != regime %}
                if (transition)
                    std::cout << "Warning!: multiple transitions in the same time step. Transition " << transition << " was ignored in favour of transition " << {{oe.target_regime.name}}_REGIME << "." << std::endl;
                transition = {{oe.target_regime.name}}_REGIME;
        {% endif %}
                {{oe.src_port_name}}_event_in_{{regime.name}}(lag);
                ++num_events;
        {% if loop.last %}
            }
        {% endif %}
    {% endfor %}
    {% if loop.last %}
        }
    {% endif %}
{% endfor %}
        /*
         * FIXME:
         * Not sure if this is necessary, Ivan thought it was but I haven't seen it
         * in NEST examples
         */
        if (num_events > 0) {
{% if (ode_solver == "cvode") %}
            /* Reinitializes CVode state if any synaptic events have occurred */
            int status = CVodeReInit(B_.sys_, tt, B_.y);
            if (check_flag(&status, "CVodeReInit", 1))
                throw CVodeSolverFailure(get_name(), status);
{% elif (ode_solver == "ida") %}
            /* Reinitializes IDA state if any synaptic events have occurred */
            int status = IDAReInit(B_.sys_, tt, B_.y, B_.yp);
            if (check_flag(&status, "IDAReInit", 1))
                throw IDASolverFailure(get_name(), status);
{% elif (ode_solver == "gsl") %}
            /* Resets the GSL stepping function if any synaptic events have occurred */
            gsl_odeiv2_step_reset(B_.s_);
{% endif %}
        }

{% for port in componentclass.analog_receive_ports %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}
        B_.logger_.record_data(current_steps + lag);
    }
}



/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    
    // Loop through event receive ports
{% for port in componentclass.event_receive_ports %}
    {%+ if not loop.first %} else {% endif %}if (e.get_rport() == {{port.name}}_EVENT_PORT)
        B_.{{port.name}}_event_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()),
            fabs(e.get_weight()) * e.get_multiplicity());
{% endfor %}
{% if componentclass.num_event_receive_ports %}
    else {
{% endif %}
        {# FIXME: Need to work out what the standard practice is in this case #}
        std::cout << "WARNING! Tried to connect unrecognised port" << std::endl;
{% if componentclass.num_event_receive_ports %}
    }
{% endif %}        
}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();
    
    // Loop through analog receive ports
{% for port in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    {%+ if not loop.first %}else {% endif %}if (e.get_rport() == {{port.name}}_ANALOG_PORT)
        B_.{{port.name}}_analog_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
{% endfor %}
{% if componentclass.num_analog_receive_ports + componentclass.num_analog_reduce_ports %}
    else
{% endif %}
        std::cout << "WARNING! Tried to connect unrecognised port" << std::endl;
{% if componentclass.num_analog_receive_ports + componentclass.num_analog_reduce_ports %}
    }
{% endif %}

}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}
