{# 
   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}
{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"



/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in componentclass.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
{# FIXME: Need to translate v->V_m
{% if ("v" in stateIndexMap) %}
    insert_(names::V_m, &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::V>);
{% endif %}
#}
  }
}


/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

{% for regime in componentclass.regimes %}
    {%- if ode_solver in ('cvode', 'ida') -%}
extern "C" int {{component_name}}_{{regime.name}}_dynamics(double t, N_Vector y_, N_Vector f_, void* pnode_) {
    {% else %}
extern "C" int {{component_name}}_{{regime.name}}_dynamics(double t, const double y_[], double f_[], void* pnode_) {
    {% endif %}

    // Get a reference to the model
    assert(pnode_);
    const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));

    // Map states used in dynamics to current namespace
    {% for state in componentclass.state_variables %}
    const double_t {{state.name}} = ITEM(y_, {{component_name}}::State_::{{state.name}}_INDEX);
    {% endfor %}

    {% set dp = componentclass.required_for(regime.time_derivatives) %}

    // Map parameters used in dynamics to current namespace
    {% for param in dp.parameters %}
    const double_t {{param.name}} = node_.P_.{{param.name}};
    {% endfor %}

    // Map port buffers to current namespace
    {% for port in dp.ports %}
    const double_t {{port.name}} = node_.B_.{{port.name}}_value;
    {% endfor %}

    // Add constants
    {% for const in dp.constants %}
    const static double_t {{const.name}} = {{const.value}}; // ({{const.units.name}})
    {% endfor %}

    // Evaluate aliases used in differential equations
    {% for expr in dp.expressions %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
    {% endfor %}

    // Evaluate differential equations
    {% for td in regime.time_derivatives %}
    ITEM(f_, {{component_name}}::State_::{{td.dependent_variable}}_INDEX) = {{td.rhs_cstr}};
    {% endfor %}

    {% if ode_solver == 'gsl' %}
    return GSL_SUCCESS;
    {% else %}
    return 0;
    {% endif %}
}
{% endfor %}


{% if ode_solver == "ida" %}
/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/
    {% for regime in componentclass.regimes %}
extern "C" int {{component_name}}_{{regime.name}}_residual (double t, N_Vector y, N_Vector yp, N_Vector f, void* pnode) {
    int status;

    // cast the node ptr to an object of the proper type
    assert(pnode);
    {{component_name}} & vnode =  *(reinterpret_cast<{{component_name}}*>(pnode));

    N_Vector y1 = vnode.B_.y1;

    status = {{component_name}}_{{regime.name}}_dynamics (t, y, y1, pnode);

        {% for i in xrange(componentclass.num_state_variables) %}
    ITEM(f, {{i}}) = ITEM(y1, {{i}}) - ITEM(yp, {{i}});
        {% endfor %}

    return status;
    {% endfor %}
}
{% endif %}


/***********************
 * Steady-sate solvers *
 ***********************/

{% if ss_solver == "kinsol" %}
  int fsolve (KINSysFn f, int N, N_Vector fval, void *user_data,
              std::string name) {
      int status;
      N_Vector u0, sc;
      void *kmem;

      u0 = N_VNew_Serial(N);
      N_VConst_Serial(0.0,u0);
      N_VConst_Serial(0.0,fval);

      sc = N_VNew_Serial(N);
      N_VConst_Serial(1.0,sc);

      kmem = KINCreate();

      status = KINSetUserData (kmem, user_data);
      if (check_flag (&status, "KinSetUserData", 1))
        throw KINSolverFailure (name, status);

      status = KINInit (kmem, f, u0);
      if (check_flag (&status, "KinInit", 1))
        throw KINSolverFailure (name, status);

      status = KINDense (kmem, N);
      if (check_flag (&status, "KinDense", 1))
        throw KINSolverFailure (name, status);

      status = KINSol (kmem, fval, KIN_NONE, sc, sc);
      if (check_flag (&status, "KINSol", 1))
        throw KINSolverFailure (name, status);

      N_VDestroy_Serial(sc);
      N_VDestroy_Serial(u0);

      KINFree (&kmem);

      return 0;
  }

  extern "C" int {{component_name}}_steadystate (N_Vector u, N_Vector f, void* pnode) {
     return 0;
  }
{% elif ss_solver == "gsl" %}
  int fsolve (int (*fss)(const gsl_vector *, void *user_data, gsl_vector *),
              int N, gsl_vector *fval, void *user_data, std::string name) {

      const gsl_multiroot_fsolver_type * T = gsl_multiroot_fsolver_hybrid;
      gsl_multiroot_fsolver * s = gsl_multiroot_fsolver_alloc (T, N);
      gsl_multiroot_function f = {fss, N, user_data};

      int status, iter;
      gsl_vector *x = gsl_vector_alloc (N);
      for (int i = 0; i < N; i++)
         gsl_vector_set (x, i, 0.0);
      gsl_multiroot_fsolver_set (s, &f, x);

      iter = 0;
      do {
         iter++;
         status = gsl_multiroot_fsolver_iterate (s);
         if ((status == GSL_EBADFUNC) || (status == GSL_ENOPROG))
            throw nest::GSLSolverFailure(name, status);
         status =  gsl_multiroot_test_residual (s->f, 1e-7);
      } while (status == GSL_CONTINUE && iter < 1000);

      for (int i = 0; i < N; i++)
         gsl_vector_set (fval, i, gsl_vector_get (s->x, i));

      gsl_vector_free (x);
      gsl_multiroot_fsolver_free (s);

      return 0;
  }
  
  extern "C" int {{component_name}}_steadystate (const gsl_vector *u, void *pnode, gsl_vector *f) {
    return 0;
  }  
{% endif %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}


{% if ode_solver == "gsl" %}
/*******************************************
 * Diagonal Jacobian approximation for GSL *
 *******************************************/

    {% for regime in componentclass.regimes %}
/** Diagonal Jacobian approximation (for GSL): (f(s+.01) - f(s))/.001 */
extern "C" int {{component_name}}_{{regime.name}}_jacobian (double t, const double y[], double *dfdy, double dfdt[], void* pnode) {
  // cast the node ptr to an object of the proper type
  assert(pnode);
  const {{component_name}} & node = *(reinterpret_cast<{{component_name}}*>(pnode));
  {{component_name}} & vnode =  *(reinterpret_cast<{{component_name}}*>(pnode));

  // state is a reference to the model state
  struct {{component_name}}::Buffers_ *b;
  b = &(vnode.B_);

  for (int i = 0; i < b->N; i++)
    b->u[i] = y[i] + 0.01;

  {{component_name}}_{{regime.name}}_dynamics(t, b->u, b->jac, pnode);
  for (int i = 0; i < b->N; i++)
    dfdt[i*b->N + i] = (b->jac[i] - dfdy[i]) / .001;
  return 0;
}
    {% endfor %}
{% endif %}


/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_():
{% for i, param in enumerate(componentclass.parameters) %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{% for param in componentclass.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
}


/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;
{% if ode_solver == "gsl" %}
    r_ = 0;
{% endif %}

{# Initialise the state #}
{# FIXME: need to add initial state here #}
{% for sv in componentclass.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{# Solve steady-state if required #}
{# This needs some thinking out, not implemented yet
{% if (ss_solver  == "kinsol") %}
    N_Vector {{SSvector}};
    ssvect = N_VNew_Serial({{steadyStateSize}});
    fsolve ({{component_name}}_steadystate, {{steadyStateSize}}, {{SSvector}},
          (void *)&p,  "{{component_name}}");
    {% for name in rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = ITEM({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    N_VDestroy_Serial ({{SSvector}});
{% elif stead_state %}
    gsl_vector *{{SSvector}};
    {{SSvector}} = gsl_vector_alloc ({{steadyStateSize}});
    fsolve ({{component_name}}_steadystate, {{steadyStateSize}}, {{SSvector}},
           (void *)&p, "{{component_name}}");
    {% for name in init.rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = gsl_vector_get({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    gsl_vector_free ({{SSvector}});
    {% for eq in init.reactionEqDefs %}
    {{eq}}
    {% endfor %}
    {% for eq in currentEqDefs %}
    {{eq}}
    {% endfor %}
    {% if ("v" in steadyStateIndexMap) %}
    y_[{{steadyStateIndexMap["v"]}}] =  v;
    {% endif %}
{% endif %}
#}
}


/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) {

{% if ode_solver == "gsl" %}
  r_ = s.r_;
{% endif %}

  for (int i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
      y_[i] = s.y_[i];
}


/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {

{% if ode_solver == "gsl" %}
  r_ = s.r_;
{% endif %}

  assert(this != &s);
  for (size_t i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
{% if ode_solver == "gsl" %}
    V_.U_old_ = S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX];
    {#{% if refractory_period %}
    V_.RefractoryCounts_ = nest::Time(nest::Time::ms(P_.t_ref)).get_steps();
    {% else %}#}
    V_.RefractoryCounts_ = 0;
    {#{% endif %}#}
{% endif %}
}


/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in componentclass.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in componentclass.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {

    // Get states from internal variables
{% for i, sv in enumerate(componentclass.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
{# FIXME: Need to include special handling of v->V_m
{% if ("v" in stateIndexMap) %}
    def<double_t>(d_, names::V_m, y_[{{stateIndexMap["v"]}}]);
{% endif %}
#}

}

void {{component_name}}::State_::set (const DictionaryDatum &d_, const Parameters_&) {

    // Set internal state variables from dictionary values
{% for i, sv in enumerate(componentclass.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
{# FIXME: Need to include special handling of v->V_m
{% if ("v" in stateIndexMap) %}
   updateValue<double_t>(d_, names::V_m, y_[{{stateIndexMap["v"]}}]);
{% endif %}
#}

}


/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n),
{% if ode_solver in ("cvode", "ida") %}
      sys_(0),
{% elif ode_solver == "gsl" %}
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0),
{%- endif %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n),
{% if ode_solver in ("cvode", "ida") %}
      sys_(0),
{% elif ode_solver == "gsl" %}
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0),
{%- endif %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in componentclass.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;

{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

{% include "init_solver.tmpl" %}
}


/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {
    recordablesMap_.create();
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_);
}


/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
{% include "destructor.tmpl" %}
}



/********************************************************
 * Trigger condition for regime changes and event outs. *
 ********************************************************/

{% include "trigger_condition.tmpl" %}


/********************************************************
 * OnEvent condition for regime changes and event outs. *
 ********************************************************/

{% for regime in componentclass.regimes %}
    {% for oe in regime.on_events %}
inline void {{component_name}}::{{oe.src_port_name}}_event_in_{{regime.name}}(nest::long_t lag) {

    // Map states used in dynamics to current namespace
        {% for sv in componentclass.state_variables %}
    const double_t {{sv.name}} = S_.y_[{{component_name}}::State_::{{sv.name}}_INDEX];
        {% endfor %}

    {% set dp = componentclass.required_for(oe.state_assignments) %}

    // Map parameters used in dynamics to current namespace
        {% for param in dp.parameters %}
    const double_t {{param.name}} = P_.{{param.name}};
        {% endfor %}

    // Map port buffers to current namespace
        {% for port in dp.ports %}
    const double_t {{port.name}} = B_.{{port.name}}_value;
        {% endfor %}

    // Add constants
    {% for const in dp.constants %}
        {% set conv = componentclass.unit_conversion_factor(const.units) %}
        {% set conv_value = conv[0] * const.value + conv[1] %}
    const static double_t {{const.name}} = {{conv_value}};  // {{const.value}} ({{const.units.name}})
    {% endfor %}

    // Add random variables
    {% for rv in dp.random_variables %}
    const double_t {{rv.name}} = {{get_random_function(rv)}}
    {% endfor %}

    // Evaluate aliases used in differential equations
        {% for expr in dp.expressions %}
            {% if hasasttr(expr, 'pieces') %}  {# Is a Piecewise statement #}
    const double_t {{expr.name}};
                {% for piece in expr.pieces %}
    {{elseif(loop.first)}} if ({{expr.condition}}) {
        {{expr_name}} = {{expr.rhs_cstr}};
                {%- endfor %}
    } else {
        {{expr_name}} = {{expr.otherwise.rhs_cstr}};
    }
            {% else %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
            {% endif %}
        {% endfor %}

    // Evaluate differential equations
        {% for assign in oe.state_assignments %}
    S_.y_[{{component_name}}::State_::{{assign.lhs}}_INDEX] = {{assign.rhs_cstr}};
        {% endfor %}
}
    {% endfor %}
{% endfor %}



/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    double dt = nest::Time::get_resolution().get_ms();
    nest::long_t current_steps = origin.get_steps();

{% include "update_work_vector.tmpl" %}  
  
    for (nest::long_t lag = from; lag < to; ++lag) {      

{% include "update_step.tmpl" %}

        // Event handling (still needs to handle events that arrive in the same
        // timestep.
        int num_events = 0;
        int transition = 0;
{% for regime in componentclass.regimes %}
        {{elseif(loop.first)}} (B_.current_regime == {{regime.name}}_REGIME) {
    {% for oe in regime.on_events %}
            {{elseif(loop.first)}} (B_.{{oe.src_port_name}}_event_port.get_value(lag)) {
        {% if oe.target_regime != regime %}
                if (transition)
                    std::cout << "Warning!: multiple transitions in the same time step. Transition " << transition << " was ignored in favour of transition " << {{oe.target_regime.name}}_REGIME << "." << std::endl;
                transition = {{oe.target_regime.name}}_REGIME;
        {% endif %}
                {{oe.src_port_name}}_event_in_{{regime.name}}(lag);
                ++num_events;
            {{endif(loop.last)}}
    {% endfor %}
        {{endif(loop.last)}}
{% endfor %}
        // FIXME: Not sure if resetting the solver is necessary, Ivan thought it was but I haven't seen it in NEST examples
        if (num_events > 0) {
{% include "reset_solver.tmpl" %}
        }

{% for port in componentclass.analog_receive_ports %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}
        B_.logger_.record_data(current_steps + lag);
    }
}



/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    // Loop through event receive ports
{% for port in componentclass.event_receive_ports %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_EVENT_PORT) {
        B_.{{port.name}}_event_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()),
            fabs(e.get_weight()) * e.get_multiplicity());
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();    
    // Loop through analog receive ports
{% for port in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_ANALOG_PORT) {
        B_.{{port.name}}_analog_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}  // End 'nineml' namespace
