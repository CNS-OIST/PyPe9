{# 
   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}
{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"



/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in componentclass.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
{# FIXME: Need to translate v->V_m
{% if ("v" in stateIndexMap) %}
    insert_(names::V_m, &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::V>);
{% endif %}
#}
  }
}


/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

{% for regime in componentclass.regimes %}
    extern "C" {% include "dynamics_signature.tmpl" %} {

    // Get a reference to the model
    assert(pnode_);
    const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));

    // Map states used in dynamics to current namespace
    {% for state in componentclass.state_variables %}
    const double_t {{state.name}} = ITEM(y_, {{component_name}}::State_::{{state.name}}_INDEX);
    {% endfor %}

    {% set dp = componentclass.required_for(regime.time_derivatives) %}

    // Map parameters used in dynamics to current namespace
    {% for param in dp.parameters %}
    const double_t {{param.name}} = node_.P_.{{param.name}};
    {% endfor %}

    // Map port buffers to current namespace
    {% for port in dp.ports %}
    const double_t {{port.name}} = node_.B_.{{port.name}}_value;
    {% endfor %}

    // Add constants
    {% for const in dp.constants %}
    const static double_t {{const.name}} = {{const.value}}; // ({{const.units.name}})
    {% endfor %}

    // Evaluate aliases used in differential equations
    {% for expr in dp.expressions %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
    {% endfor %}

    // Evaluate differential equations
    {% for td in regime.time_derivatives %}
    ITEM(f_, {{component_name}}::State_::{{td.dependent_variable}}_INDEX) = {{td.rhs_cstr}};
    {% endfor %}

    {% include "dynamics_return.tmpl" %}
}
{% endfor %}


/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/

{% include "residual.tmpl" %}


/***********************
 * Steady-sate solvers *
 ***********************/

{% include "fsolve.tmpl" %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}


/***********************************************
 * Diagonal Jacobian approximation if required *
 ***********************************************/

{% include "jacobian.tmpl" %}


/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_():
{% for i, param in enumerate(componentclass.parameters) %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{% for param in componentclass.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
}


/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
{% for sv in componentclass.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{% include "solve_steady_state.tmpl" %}
}

/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) {
  for (int i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
      y_[i] = s.y_[i];
}


/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {
  assert(this != &s);
  for (size_t i = 0 ; i < {{componentclass.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
}


/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in componentclass.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in componentclass.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {

    // Get states from internal variables
{% for i, sv in enumerate(componentclass.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
{# FIXME: Need to include special handling of v->V_m
{% if ("v" in stateIndexMap) %}
    def<double_t>(d_, names::V_m, y_[{{stateIndexMap["v"]}}]);
{% endif %}
#}

}

void {{component_name}}::State_::set (const DictionaryDatum &d_, const Parameters_&) {

    // Set internal state variables from dictionary values
{% for i, sv in enumerate(componentclass.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
{# FIXME: Need to include special handling of v->V_m
{% if ("v" in stateIndexMap) %}
   updateValue<double_t>(d_, names::V_m, y_[{{stateIndexMap["v"]}}]);
{% endif %}
#}

}


/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n),
{% include "buffer_vars.tmpl" %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n),
{% include "buffer_vars.tmpl" %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in componentclass.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;

{% for p in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

{% include "init_solver.tmpl" %}
}


/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {
    recordablesMap_.create();
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_);
}


/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
{% include "destructor.tmpl" %}
}



/********************************************************
 * Trigger condition for regime changes and event outs. *
 ********************************************************/

{% include "trigger_condition.tmpl" %}


/********************************************************
 * OnEvent condition for regime changes and event outs. *
 ********************************************************/

{% for regime in componentclass.regimes %}
    {% for oe in regime.on_events %}
inline void {{component_name}}::{{oe.src_port_name}}_event_in_{{regime.name}}(nest::long_t lag) {

    // Map states used in dynamics to current namespace
        {% for sv in componentclass.state_variables %}
    const double_t {{sv.name}} = S_.y_[{{component_name}}::State_::{{sv.name}}_INDEX];
        {% endfor %}

    {% set dp = componentclass.required_for(oe.state_assignments) %}

    // Map parameters used in dynamics to current namespace
        {% for param in dp.parameters %}
    const double_t {{param.name}} = P_.{{param.name}};
        {% endfor %}

    // Map port buffers to current namespace
        {% for port in dp.ports %}
    const double_t {{port.name}} = B_.{{port.name}}_value;
        {% endfor %}

    // Add constants
    {% for const in dp.constants %}
        {% set conv = componentclass.unit_conversion_factor(const.units) %}
        {% set conv_value = conv[0] * const.value + conv[1] %}
    const static double_t {{const.name}} = {{conv_value}};  // {{const.value}} ({{const.units.name}})
    {% endfor %}

    // Add random variables
    {% for rv in dp.random_variables %}
    const double_t {{rv.name}} = {{get_random_function(rv)}}
    {% endfor %}

    // Evaluate aliases used in differential equations
        {% for expr in dp.expressions %}
            {% if hasasttr(expr, 'pieces') %}  {# Is a Piecewise statement #}
    const double_t {{expr.name}};
                {% for piece in expr.pieces %}
    {{elseif(loop.first)}} if ({{expr.condition}}) {
        {{expr_name}} = {{expr.rhs_cstr}};
                {%- endfor %}
    } else {
        {{expr_name}} = {{expr.otherwise.rhs_cstr}};
    }
            {% else %}
    const double_t {{expr.lhs}} = {{expr.rhs_cstr}};
            {% endif %}
        {% endfor %}

    // Evaluate differential equations
        {% for assign in oe.state_assignments %}
    S_.y_[{{component_name}}::State_::{{assign.lhs}}_INDEX] = {{assign.rhs_cstr}};
        {% endfor %}
}
    {% endfor %}
{% endfor %}



/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    double dt = nest::Time::get_resolution().get_ms();
    nest::long_t current_steps = origin.get_steps();

    double f_[{{component_name}}::State_::STATE_VEC_SIZE_];  // Vector to hold the time derivatives
  
    for (nest::long_t lag = from; lag < to; ++lag) {      

{% include "update_step.tmpl" %}

        // Event handling (still needs to handle events that arrive in the same
        // timestep.
        int num_events = 0;
        int transition = 0;
{% for regime in componentclass.regimes %}
        {{elseif(loop.first)}} (B_.current_regime == {{regime.name}}_REGIME) {
    {% for oe in regime.on_events %}
            {{elseif(loop.first)}} (B_.{{oe.src_port_name}}_event_port.get_value(lag)) {
        {% if oe.target_regime != regime %}
                if (transition)
                    std::cout << "Warning!: multiple transitions in the same time step. Transition " << transition << " was ignored in favour of transition " << {{oe.target_regime.name}}_REGIME << "." << std::endl;
                transition = {{oe.target_regime.name}}_REGIME;
        {% endif %}
                {{oe.src_port_name}}_event_in_{{regime.name}}(lag);
                ++num_events;
            {{endif(loop.last)}}
    {% endfor %}
        {{endif(loop.last)}}
{% endfor %}
        // FIXME: Not sure if resetting the solver is necessary, Ivan thought it was but I haven't seen it in NEST examples
        if (num_events > 0) {
{% include "reset_solver.tmpl" %}
        }

{% for port in componentclass.analog_receive_ports %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}
        B_.logger_.record_data(current_steps + lag);
    }
}



/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    // Loop through event receive ports
{% for port in componentclass.event_receive_ports %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_EVENT_PORT) {
        B_.{{port.name}}_event_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()),
            fabs(e.get_weight()) * e.get_multiplicity());
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();    
    // Loop through analog receive ports
{% for port in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_ANALOG_PORT) {
        B_.{{port.name}}_analog_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}  // End 'nineml' namespace
