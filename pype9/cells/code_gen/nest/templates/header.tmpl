{# This template provides a CVODE exception class

   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#ifndef {{component_name | upper}}_H
#define {{component_name | upper}}_H

{% include "header-includes.tmpl" %}

namespace nineml {

{% include "solver-preludes.tmpl" %}

{% for regime in componentclass.regimes %}
    {% if ode_solver == "cvode" or ode_solver == "ida" %}
  extern "C" int {{component_name}}_{{regime.name}}_dynamics (double, const N_Vector, N_Vector, void*);
  extern "C" int {{component_name}}_{{regime.name}}_residual (double, N_Vector, N_Vector, N_Vector, void*);
        {% if ode_solver == "cvode" %}
  extern "C" int {{component_name}}_{{regime.name}}_event (double, N_Vector, double *, void*);
        {% else %}
  extern "C" int {{component_name}}_{{regime.name}}_event (double, N_Vector, N_Vector, double *, void*);
        {% endif %}
    {% elif ode_solver == 'gsl' %}
  extern "C" int {{component_name}}_{{regime.name}}_dynamics (double, const double*, double*, void*);
    {% endif %}
{% endfor %}

{% if ss_solver == "kinsol" %}
  extern "C" int {{component_name}}_steadystate (N_Vector, N_Vector, void*);
{% elif ss_solver == 'gsl' %}
  extern "C" int {{component_name}}_steadystate (const gsl_vector *, void *, gsl_vector *);
{% endif %}

  class {{component_name}} : public nest::Archiving_Node {

   public:

    ~{{component_name}}();
    {{component_name}}(const {{component_name}} &);
    {{component_name}}();

    /**
     * Import sets of overloaded virtual functions.
     * This is necessary to ensure proper overload and overriding resolution.
     * @see http://www.gotw.ca/gotw/005.htm.
     */
    using nest::Node::connect_sender;
    using nest::Node::handle;

    nest::port check_connection(nest::Connection&, nest::port);

    void handle(nest::SpikeEvent &);
    void handle(nest::CurrentEvent &);
    void handle(nest::DataLoggingRequest &);

    nest::port connect_sender(nest::SpikeEvent &, nest::port);
    nest::port connect_sender(nest::CurrentEvent &, nest::port);
    nest::port connect_sender(nest::DataLoggingRequest &, nest::port);

    void get_status(DictionaryDatum &) const;
    void set_status(const DictionaryDatum &);

    void init_node_(const nest::Node& proto);
    void init_state_(const nest::Node& proto);
    void init_buffers_();
    void calibrate();

    void update(nest::Time const &, const nest::long_t, const nest::long_t);

    // Set dynamics methods (the ones that actually model the dynamics) as friends
{% if ode_solver == "cvode" %}
    friend int {{component_name}}_dynamics (double, const N_Vector, N_Vector, void*);
    friend int {{component_name}}_event (double, N_Vector, double *, void*);
{% elif ode_solver == "ida" %}
    friend int {{component_name}}_residual (double, N_Vector, N_Vector, N_Vector, void*);
    friend int {{component_name}}_event (double, N_Vector, N_Vector, double *, void*);
{% elif ode_solver == "gsl" %}
    friend int {{component_name}}_dynamics (double, const double*, double*, void*);
{% endif %}
{% if ss_solver == "kinsol" %}
    friend  int {{component_name}}_steadystate (N_Vector, N_Vector, void*);
{% elif ss_solver == 'gsl' %}
    friend  int {{component_name}}_steadystate (const gsl_vector *, void *, gsl_vector *);
{% endif %}

    // Regime ids
    static const int DEFAULT_REGIME_ = 0;
    enum Regimes {
        {% for regime in componentclass.regimes %}
            {% if loop.first %}
        {{regime.name}}_REGIME = DEFAULT_REGIME_,
            {% else %}
        {{regime.name}}_REGIME,
            {% endif -%}
        {% endfor %}
        SUP_REGIME_
    };


{% if componentclass.event_receive_ports %}
    /* Event port ids
     * @note Start with 1 so we can forbid port 0 to avoid accidental
     *     creation of connections with no receptor type set.
     */
    static const nest::port MIN_EVENT_PORT_ = 1;
    enum EventPorts {
    {% for port in componentclass.event_receive_ports %}
        {% if loop.first %}
        {{port.name}}_EVENT_PORT = MIN_EVENT_PORT_,
        {% else %}
        {{port.name}}_EVENT_PORT,
        {% endif %}
    {% endfor %}
        SUP_EVENT_PORT_
    };

    // On event ids
    enum OnEvents {
    {% for regime in componentclass.regimes %}
        {% for oe in regime.on_events %}
        {{oe.src_port_name}}_ON_EVENT,
        {% endfor %}
    {% endfor %}
        SUP_ON_EVENT_
    };

{% endif %}
{% if componentclass.analog_receive_ports %}
    //Analog port ids
    static const nest::port MIN_ANALOG_PORT_ = {% if componentclass.analog_receive_ports %}SUP_EVENT_PORT_{% else %}1{% endif %};
    enum AnalogPorts {
    {% for port in componentclass.analog_receive_ports %}
        {% if loop.first %}
        {{port.name}}_ANALOG_PORT = MIN_ANALOG_PORT_,
        {% else %}
        {{port.name}}_ANALOG_PORT,
        {% endif %}
    {% endfor %}
        SUP_ANALOG_PORT_
    };


{% endif %}
    // Synaptic event function definitions
{% for regime in componentclass.regimes %}
    {% for oe in regime.on_events %}
    inline void {{oe.src_port_name}}_event_in_{{regime.name}}(nest::long_t lag);
    {% endfor %}
{% endfor %}

    // The next two classes need to be friends to access the State_ class/member
    friend class nest::RecordablesMap<{{component_name}}>;
    friend class nest::UniversalDataLogger<{{component_name}}>;

    struct Parameters_ {
{% for param in componentclass.parameters %}
        double {{param.name}};
{% endfor %}
        Parameters_();
        void get(DictionaryDatum&) const;
        void set(const DictionaryDatum&);
    }; // end struct Parameters_

    struct State_ {

      enum StateVecElems {
{% for sv in componentclass.state_variables %}
    {% if loop.first %}
        {{sv.name}}_INDEX = 0,
    {% else %}
        {{sv.name}}_INDEX,
    {% endif %}
{% endfor %}
        STATE_VEC_SIZE_
      };


      double y_[STATE_VEC_SIZE_];
{% if ode_solver == "gsl" %}
      nest::int_t r_; /* refractory counter */
{% endif %}


      State_(const Parameters_& p);
      State_(const State_& s);
      State_& operator=(const State_& s);
      void get(DictionaryDatum&) const;
      void set(const DictionaryDatum&, const Parameters_&);
    }; // end struct State_


{% if ode_solver in ("cvode", "ida") %}
    struct Variables_ {};
{% elif ode_solver == "gsl"  %}
    struct Variables_ { nest::int_t RefractoryCounts_; double U_old_; /* for spike-detection */ };
{% endif %}

    struct Buffers_ {

        Buffers_({{component_name}}&);
        Buffers_(const Buffers_&, {{component_name}}&);
        nest::UniversalDataLogger<{{component_name}}> logger_;

        // Structures required by the solver
{% if ode_solver == "cvode" %}
        N_Vector y;  //!< current state vector used by CVode
        void *   sys_;  //!< CVode control structure
{% elif ode_solver == "ida" %}
        N_Vector y, y1;  //!< current state vector used by IDA
        N_Vector yp;  //!< derivatives vector used by IDA
        void *   sys_;  //!< IDA control structure
{% elif ode_solver == "gsl" %}
		gsl_odeiv2_step*  s_;  //!< stepping function
		gsl_odeiv2_control* c_;  //!< adaptive stepsize control function
		gsl_odeiv2_evolve*  e_;  //!< evolution function
		gsl_odeiv2_system   sys_;  //!< struct describing system
		unsigned int N;  // size of state vector used by Jacobian
		double *u, *jac;  // intermediate state vectors used for Jacobian approximation
{% endif %}

        // Timesteps
        double_t step_;       //!< step size in ms
        double   IntegrationStep_;//!< current integration time step, updated by solver


        // Event receive port buffers
{% for port in componentclass.event_receive_ports %}
        nest::RingBuffer {{port.name}}_event_port;
{% endfor %}

        // Analog receive port buffers
{% for port in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
        nest::RingBuffer {{port.name}}_analog_port;
{% endfor %}

        // Variables to hold the last value of the analog receive port buffers
{% for port in chain(componentclass.analog_receive_ports, componentclass.analog_reduce_ports) %}
        double_t {{port.name}}_value;
{% endfor %}


        // Holds the id of the current regime
        int current_regime;


	}; // end struct Buffers_


	template <State_::StateVecElems elem>
	double_t get_y_elem_() const { return S_.y_[elem]; }

	Parameters_ P_;
	State_      S_;
	Variables_  V_;
	Buffers_    B_;

    //! Mapping of recordables names to access functions	
	static nest::RecordablesMap<{{component_name}}> recordablesMap_;

  }; // end class {{component_name}}

  inline nest::port {{component_name}}::check_connection(nest::Connection& c, nest::port receptor_type) {
	  nest::SpikeEvent e;
	  e.set_sender(*this);
	  c.check_event(e);
	  return c.get_target()->connect_sender(e, receptor_type);
  }

  inline nest::port {{component_name}}::connect_sender(nest::SpikeEvent&, nest::port receptor_type) {
    if (receptor_type < 0 || receptor_type >= SUP_EVENT_PORT_)
      throw nest::UnknownReceptorType(receptor_type, this->get_name());
    else if (receptor_type < MIN_EVENT_PORT_)
      throw nest::IncompatibleReceptorType(receptor_type, this->get_name(), "SpikeEvent");
    return receptor_type;
  }


  inline nest::port {{component_name}}::connect_sender(nest::CurrentEvent&, nest::port receptor_type) {
    if (receptor_type != 0)
      throw nest::UnknownReceptorType(receptor_type, this->get_name());
    return 0;
  }


  inline nest::port {{component_name}}::connect_sender(nest::DataLoggingRequest& dlr, nest::port receptor_type) {
    if (receptor_type != 0)
      throw nest::UnknownReceptorType(receptor_type, this->get_name());
    return B_.logger_.connect_logging_device(dlr, recordablesMap_);
  }


  inline void {{component_name}}::get_status(DictionaryDatum &d) const {
    P_.get(d);
    S_.get(d);
    nest::Archiving_Node::get_status(d);
    (*d)[nest::names::recordables] = recordablesMap_.get_list();
    def<double_t>(d, nest::names::t_spike, get_spiketime_ms());
    DictionaryDatum receptor_dict_ = new Dictionary();
    // Synaptic event dictionary
{% for port in componentclass.event_receive_ports %}
    (*receptor_dict_)[Name("{{port.name}}")]  = {{port.name}}_EVENT_PORT;
{% endfor %}
    (*d)[nest::names::receptor_types] = receptor_dict_;
  }


  inline void {{component_name}}::set_status(const DictionaryDatum &d) {
    Parameters_ ptmp = P_;  // temporary copy in case of errors
    ptmp.set(d);             // throws if BadProperty
    State_    stmp = S_;  // temporary copy in case of errors
    stmp.set(d, ptmp);         // throws if BadProperty
    // We now know that (ptmp, stmp) are consistent. We do not
    // write them back to (P_, S_) before we are also sure that
	// the properties to be set in the parent class are internally
	// consistent.
	nest::Archiving_Node::set_status(d);
	// if we get here, temporaries contain consistent set of properties
	P_ = ptmp;
	S_ = stmp;	
    calibrate();
  }

} // end namespace nest

#endif // {{component_name | upper}}_H
