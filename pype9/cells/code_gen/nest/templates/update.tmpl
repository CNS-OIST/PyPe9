{#
   NEST update template

   This template defines a C++ function of the form:

   int ModelName_update (nest::Time const & origin, const nest::long_t from, const nest::long_t to)

   This is the model state update function invoked by the NEST simulator.

   Template variables are:

   - ode_solver: the current used solver method; can be "cvode" "ida" or "gsl"
   - ModelName: the name of the current system
   - stateIndexMap - a dictionary mapping state names to state vector indices
                     (state "v" is always at index 0)

   This template invokes the "NEST-emit-spike.tmpl" template in order
   to generate code that handles detection of spiking threshold and
   generation of corresponding spike events.

   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

// TEMPLATE: update <<<
void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    nest::long_t current_steps = origin.get_steps();

    for (nest::long_t lag = from; lag < to; ++lag) {
        double dt = B_.step_;
        double tt = 0.0;

{% if ode_solver in ('cvode', 'ida') %}
    {% if ode_solver == 'cvode' %}
        {% set abbrev = 'CV' %}
        {% set prefix = 'CVode' %}
        {% set solver = 'CVode' %}
    {% else %}
        {% set abbrev = 'IDA' %}
        {% set prefix = 'IDA' %}
        {% set solver = 'IDASolve' %}
    {% endif %}
	    int N = NV_LENGTH_S (B_.y);
	    double tout = (current_steps+lag) * dt;

		// adaptive step integration
        while (tt < tout) {
            const int status = {{solver}} (B_.sys_, tout,
    {% if ode_solver == 'cvode' %}
                                                B_.y, &tt,
    {% elif ode_solver == 'ida' %}
                                                &tt, B_.y, B_.yp,
    {% endif %}
                                                {{abbrev}}_NORMAL);
            switch (status) {
                case {{abbrev}}_SUCCESS:      continue;
                case {{abbrev}}_ROOT_RETURN: {
                    set_spiketime(nest::Time::ms(tt));
	                nest::SpikeEvent se;
	                // Copy solver state to NEST state
	                for (int i = 0; i < N; i++)
	                    S_.y_[i] = ITEM(B_.y,i);
	                network()->send(*this, se, lag);
	                adjust_zero_crossings(B_.y, {{abs_tolerance}});
                    continue;
                }
                case {{abbrev}}_TSTOP_RETURN: break;
                default:
                    throw {{prefix}}SolverFailure (get_name(), 0);
            }
	   	}

        // Copy items from CVODE/IDA vector to NEST state array.
	    for (int i = 0; i < N; i++)
	       S_.y_[i] = ITEM(B_.y, i);
{% elif ode_solver == "gsl" %}
	    V_.U_old_ = S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX];

	    while (tt < dt) {
	      const int status =  gsl_odeiv2_evolve_apply(B_.e_, B_.c_, B_.s_,
	                                                  &B_.sys_, // system of ODE
	                                                  &tt, // from t...
	                                                  dt, // ...to t= t + dt
	                                                  &B_.IntegrationStep_, // integration window (written on!)
	                                                  S_.y_); // neuron state
	      if (status != GSL_SUCCESS)
	        throw nest::GSLSolverFailure(get_name(), status);
	    }

		// Check threshold if not refractory and emit spike if crossed
	    if ( S_.r_ > 0 )
	       S_.r_--;
	    {# FIXME: This threshold crossing should be handled by regimes #}
	    else if (S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX] >= {{v_threshold}} &&
	             V_.U_old_ > S_.y_[{{component_name}}::State_::{{componentclass.annotations[PYPE9_NS][MEMBRANE_VOLTAGE]}}_INDEX]) {
	        S_.r_ = V_.RefractoryCounts_;
	        set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
	        nest::SpikeEvent se;
	        network()->send(*this, se, lag);
	    }
{% endif %}

{# Event handling #}
	    // Event handling (still needs to handle events that arrive in the same
	    // timestep.
	    int num_events = 0;
{% if componentclass.num_regimes > 1 %}
    int transition = 0;
{% endif %}
{% for regime in componentclass.regimes %}
        {%+ if not loop.first %}} else {% endif %}if (B_.current_regime == {{regime.name}}_REGIME) {
    {% for oe in regime.on_events %}
            {%+ if not loop.first %}} else {% endif %}if (B_.{{oe.src_port_name}}_event_port.get_value(lag)) {
        {% if oe.target_regime != regime %}
	            if (transition)
	                std::cout << "Warning!: multiple transitions in the same time step. Transition " << transition << " was ignored in favour of transition " << {{oe.target_regime.name}}_REGIME << "." << std::endl;
	            transition = {{oe.target_regime.name}}_REGIME;
        {% endif %}
	            {{oe.src_port_name}}_event_in_{{regime.name}}(lag);
	            ++num_events;
        {% if loop.last %}
            }
        {% endif %}
    {% endfor %}
    {% if loop.last %}
        }
    {% endif %}
{% endfor %}
	    /*
	     * FIXME:
	     * Not sure if this is necessary, Ivan thought it was but I haven't seen it
	     * in NEST examples
	     */
	    if (num_events > 0) {
{% if (ode_solver == "cvode") %}
	        /* Reinitializes CVode state if any synaptic events have occurred */
	        int status = CVodeReInit(B_.sys_, tt, B_.y);
	        if (check_flag(&status, "CVodeReInit", 1))
	            throw CVodeSolverFailure(get_name(), status);
{% elif (ode_solver == "ida") %}
	        /* Reinitializes IDA state if any synaptic events have occurred */
	        int status = IDAReInit(B_.sys_, tt, B_.y, B_.yp);
	        if (check_flag(&status, "IDAReInit", 1))
	            throw IDASolverFailure(get_name(), status);
{% elif (ode_solver == "gsl") %}
	        /* Resets the GSL stepping function if any synaptic events have occurred */
	        gsl_odeiv2_step_reset(B_.s_);
{% endif %}
        }

{% for port in componentclass.analog_receive_ports %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}
        B_.logger_.record_data(current_steps + lag);
    }
}
// TEMPLATE: update >>>