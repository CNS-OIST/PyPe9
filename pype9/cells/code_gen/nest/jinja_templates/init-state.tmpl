{# This template adds State class constructors and assignments

   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}


//-------------------------------------------------//
// This section was generated from init-state.tmpl //
//-------------------------------------------------//
/**
 * Construct state from parameters.
 */
{{component.name}}}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;
{% if (ode_solver == "gsl") %}
    r_ = 0;
{% endif %}

{# Initialise the state #}
{% for state, val in izip(state_variables, state_variables_init) %}
    y_[{{state}}_INDEX] = {{val}};
{% endfor %}

{# Solve steady-state if required #}
{# This needs some thinking out, not implemented yet
{% if (ss_solver  == "kinsol") %}
    N_Vector {{SSvector}};
    ssvect = N_VNew_Serial({{steadyStateSize}});
    fsolve ({{component.name}}}}_steadystate, {{steadyStateSize}}, {{SSvector}},
          (void *)&p,  "{{component.name}}}}");
    {% for name in rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = ITEM({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    N_VDestroy_Serial ({{SSvector}});
{% elif stead_state %}
    gsl_vector *{{SSvector}};
    {{SSvector}} = gsl_vector_alloc ({{steadyStateSize}});
    fsolve ({{component.name}}}}_steadystate, {{steadyStateSize}}, {{SSvector}},
           (void *)&p, "{{component.name}}}}");             
    {% for name in init.rateEqStates %}
        {% if (name in steadyStateIndexMap) %}
    y_[{{stateIndexMap[name]}}] = gsl_vector_get({{SSvector}}, {{steadyStateIndexMap[name]}});
        {% else %}
    y_[{{stateIndexMap[name]}}] = {{name}};
        {% endif %}
    {% endfor %}
    gsl_vector_free ({{SSvector}});
    {% for eq in init.reactionEqDefs %}
    {{eq}}
    {% endfor %}
    {% for eq in currentEqDefs %}
    {{eq}}
    {% endfor %}
    {% if ("v" in steadyStateIndexMap) %}
    y_[{{steadyStateIndexMap["v"]}}] =  v;
    {% endif %}
{% endif %}
#}
}

/**
 * Copy constructor for State class
 */
{{component.name}}}}::State_::State_(const State_& s) {

{% if (ode_solver == "gsl") %}
  r_ = s.r_;
{% endif %}
        
  for ( int i = 0 ; i < {{len(componentclass.state_variables)}} ; ++i )
      y_[i] = s.y_[i];
}

/**
 * Assignment of a State from another State
 */
{{component.name}}}}::State_& {{component.name}}}}::State_::operator=(const State_& s) {

{% if (ode_solver == "gsl") %}
  r_ = s.r_;
{% endif %}
        
  assert(this != &s);  
  for ( size_t i = 0 ; i < {{len(componentclass.state_variables)}} ; ++i )
       y_[i] = s.y_[i];

  return *this;
}

void {{component.name}}}}::calibrate() {
    B_.logger_.init();  
{% if (ode_solver == "gsl") %}
    V_.U_old_ = S_.y_[{{component.name}}}}::State_::{{membrane_voltage}}_INDEX];
    {% if refractory_period %}
    V_.RefractoryCounts_ = Time(Time::ms(P_.t_ref)).get_steps();
    {% else %}
    V_.RefractoryCounts_ = 0;
    {% endif %}
{% endif %}
}
// ------------------- init-state.tmpl ------------------------//
