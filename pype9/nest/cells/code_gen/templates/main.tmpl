{# 
   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

{% import "macros.tmpl" as macros %}

{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"



/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in component_class.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
  }
}


/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {


extern "C" {% include "dynamics_signature.tmpl" %} {

	// Get references to the members of the model
	assert(pnode_);
	const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));
	const {{component_name}}::Parameters_& P_ = node_.P_;
	const {{component_name}}::State_& S_ = node_.S_;
	const {{component_name}}::Buffers_& B_ = node_.B_;

{% for regime in component_class.regimes %}
    {{elseif(loop.first)}} (B_.current_regime == {{component_name}}::{{regime.name}}_REGIME) {
	    {{macros.map_required_vars_locally(regime.time_derivatives, component_class, component_name, unit_handler) | indent(8)}}
	    // Evaluate differential equations
	{% for td, scaled_expr, units in unit_handler.scale_time_derivatives(regime.time_derivatives) %}
	    //std::cout << "{{td.dependent_variable}}=" << {{scaled_expr.rhs_cstr}};
	    ITEM(f_, {{component_name}}::State_::{{td.dependent_variable}}_INDEX) = {{scaled_expr.rhs_cstr}};  // ({{units}})
	{% endfor %}
    {{endif(loop.last)}}
{% endfor %}

    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
    {% include "dynamics_return.tmpl" %}

}



/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/

{% include "residual.tmpl" %}


/***********************
 * Steady-sate solvers *
 ***********************/

{% include "fsolve.tmpl" %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}


/***********************************************
 * Diagonal Jacobian approximation if required *
 ***********************************************/

{% include "jacobian.tmpl" %}


/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_():
{% for i, param in enumerate(component_class.parameters) %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{% for param in component_class.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
}


/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
{% for sv in component_class.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{% include "solve_steady_state.tmpl" %}
}

/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) {
  for (int i = 0 ; i < {{component_class.num_state_variables}} ; ++i)
      y_[i] = s.y_[i];
}


/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {
  assert(this != &s);
  for (size_t i = 0 ; i < {{component_class.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];

  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
}


/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in component_class.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in component_class.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {
    // Get states from internal variables
{% for i, sv in enumerate(component_class.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
}

void {{component_name}}::State_::set (const DictionaryDatum &d_, const Parameters_&) {
    // Set internal state variables from dictionary values
{% for i, sv in enumerate(component_class.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
}


/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n),
{% include "buffer_vars.tmpl" %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n),
{% include "buffer_vars.tmpl" %}
      current_regime(DEFAULT_REGIME_) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in component_class.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;

{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

{% include "init_solver.tmpl" %}
}


/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {

    recordablesMap_.create();
    
    double t = 0.0;
    {{macros.map_required_vars_locally(component_class.regime(default_regime).all_triggers(), component_class, component_name, unit_handler) | indent(4)}}

    {{macros.set_triggers(component_class.regime(default_regime), component_class, component_name, unit_handler) | indent}}
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);

    double t = 0.0;
    {{macros.map_required_vars_locally(component_class.regime(default_regime).all_triggers(), component_class, component_name, unit_handler) | indent(4)}}

    {{macros.set_triggers(component_class.regime(default_regime), component_class, component_name, unit_handler) | indent}}    
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_);

    double t = 0.0;
    {{macros.map_required_vars_locally(component_class.regime(default_regime).all_triggers(), component_class, component_name, unit_handler) | indent(4)}}

    {{macros.set_triggers(component_class.regime(default_regime), component_class, component_name, unit_handler) | indent}}    
}


/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
{% include "destructor.tmpl" %}
}


/************************************************************************
 * Function to be solved for its roots be solver to exact trigger times *
 ************************************************************************/

{% include "trigger_roots.tmpl" %}


/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    double dt = nest::Time::get_resolution().get_ms();
    nest::long_t current_steps = origin.get_steps();

    double f_[{{component_name}}::State_::STATE_VEC_SIZE_];  // Vector to hold the time derivatives
  
    for (nest::long_t lag = from; lag < to; ++lag) {
    
        /***** Transition handling *****/

        bool reset_solver = false;

        // FIXME: Should include precisely timed change of regimes within lags

{% for regime in component_class.regimes %}
        {{elseif(loop.first)}} (B_.current_regime == {{regime.name}}_REGIME) {

    {% if regime.num_time_derivatives %}
            /***** ODE update *****/
            {% include "update_step.tmpl" %}
    {% endif %}
        
            // Get the simulation time in case it is needed in the triggers or assignments
            double t = origin.get_ms() + lag * dt;

            //std::cout << "Regime: {{regime.name}} at time " << t << std::endl;            
        
            {{macros.map_required_vars_locally(chain(regime.all_triggers(), regime.all_target_triggers(), regime.all_state_assignments()), component_class, component_name, unit_handler) | indent(12)}}

            int transition = -1;
    {% for trans in regime.transitions %}
        {% if hasattr(trans, 'trigger') %}
            // Check trigger condition
            if ({{trans.trigger.rhs_cstr}}) {
                // Check to see if trigger is active (i.e. was false since on the change from false->true triggers a transition)
                if (B_.{{regime.name}}_trigger_{{regime.index_of(trans)}}_active) {
                    // Deactivate the trigger (triggers are only triggered when the change from false -> true)
                    B_.{{regime.name}}_trigger_{{regime.index_of(trans)}}_active = false;
        {% else %}
            // Check for incoming event
            if (B_.{{trans.src_port_name}}_event_port.get_value(lag)) {
        {% endif %}

				    // State assignments
        {% for sa, scaled_expr, units in unit_handler.scale_aliases(trans.state_assignments) %}
				    S_.y_[{{component_name}}::State_::{{sa.name}}_INDEX] = {{scaled_expr}};  // ({{units}})
        {% endfor %}

				    // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
				    // Output events
        {% for output_event in trans.output_events %}
				    set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
				    nest::SpikeEvent se;
				    network()->send(*this, se, lag);
        {% endfor %}
                
        {% if trans.target_regime != regime %}
                    // FIXME: Need to work out the best way to emit a warning in NEST.        
                    // Set transition to new regime
                    if (transition < 0)
                        B_.current_regime = transition = {{trans.target_regime.name}}_REGIME;
                    else 
                        std::cout << "Warning!: multiple transitions in the same time step. Transition to 'Regime " << transition << "' was ignored in favour of transition " << {{trans.target_regime.name}}_REGIME << "." << std::endl;

                    {{macros.set_triggers(trans.target_regime, component_class, component_name, unit_handler) | indent(20)}}
        {% endif %}
                    // Flag the solver to be reset if required               
                    reset_solver = true;
        {% if hasattr(trans, 'trigger') %}
                }
            } else
                // Activate the trigger
                B_.{{regime.name}}_trigger_{{regime.index_of(trans)}}_active = true;
        {% else %}
            }
        {% endif %}  
    {% endfor %}
        {{endif(loop.last)}}    
{% endfor %}

        if (reset_solver) {
{% include "reset_solver.tmpl" %}

        }

        /***** Get analog port values *****/
    
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}
        B_.logger_.record_data(current_steps + lag);
    }
}


/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);
    // Loop through event receive ports
{% for port in component_class.event_receive_ports %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_EVENT_PORT) {
        B_.{{port.name}}_event_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()),
            fabs(e.get_weight()) * e.get_multiplicity());
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();    
    // Loop through analog receive ports
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_ANALOG_PORT) {
        B_.{{port.name}}_analog_port.add_value(
            e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
    {{endif(loop.last)}}
{% endfor %}
}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}

}  // End 'nineml' namespace
