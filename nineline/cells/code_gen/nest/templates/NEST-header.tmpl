{# This template provides a CVODE exception class

   Authors: Ivan Raikov and Thomas G. Close
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//--------------------------------------------------//
// This section was generated from NEST-header.tmpl //
//--------------------------------------------------//

/* This file was generated by NineLine version {{version}} on {{timestamp}} */

#include "nest.h"
#include "event.h"
#include "archiving_node.h"
#include "ring_buffer.h"
#include "connection.h"
#include "universal_data_logger.h"
#include "recordables_map.h"

{% if (ODEmethod == "cvode") %}
#include <sundials/sundials_types.h> /* definition of type realtype */
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <cvode/cvode.h>       /* prototypes for CVODE fcts., consts. */
#include <cvode/cvode_diag.h>    /* prototype for CVDiag */
#define GET_ITEM(v,i)  NV_Ith_S(v,i)  /* Ith component in a vector */
{% elif (ODEmethod == "ida") %}
#include <sundials/sundials_types.h> /* definition of type realtype */
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <ida/ida.h>         /* prototypes for IDA fcts., consts. */
#include <ida/ida_dense.h>
#define GET_ITEM(v,i)  NV_Ith_S(v,i)  /* Ith component in a vector */
{% elif (ODEmethod == "gsl") %}
#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_sf_exp.h>
#include <gsl/gsl_odeiv2.h>
#define Ith(v,i)  (v[i])
{% endif %}

{% if (SSmethod == "kinsol") %}
#include <sundials/sundials_types.h> /* definition of type realtype */
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <kinsol/kinsol.h>       /* prototypes for KINSOL fcts. */
#include <kinsol/kinsol_dense.h>   /* prototype for KINDense */
{% else %}
#include <gsl/gsl_vector.h>
#include <gsl/gsl_multiroots.h>
{% endif %}


namespace nest {

{% if (ODEmethod == "cvode") %}
    {% include "NEST-cvode-prelude.tmpl" %}
{% elif (ODEmethod == "ida") %}
    {% include "NEST-ida-prelude.tmpl" %}
{% endif %}
{% if (SSmethod == "kinsol") %}
    {% include "NEST-kinsol-prelude.tmpl" %}
{% endif %}
{% if (ODEmethod == "cvode") %}
  extern "C" int {{ModelName}}_dynamics (double, const N_Vector, N_Vector, void*);
  extern "C" int {{ModelName}}_event (double, N_Vector, double *, void*);
{% elif (ODEmethod == "ida") %}
  extern "C" int {{ModelName}}_residual (double, N_Vector, N_Vector, N_Vector, void*);
  extern "C" int {{ModelName}}_event (double, N_Vector, N_Vector, double *, void*);
{% else %}
  extern "C" int {{ModelName}}_dynamics (double, const double*, double*, void*);
{% endif %}
{% if (steadyStateSize > 0) %}
    {% if (SSmethod == "kinsol") %}
  extern "C" int {{ModelName}}_steadystate (N_Vector, N_Vector, void*);
    {% else %}
  extern "C" int {{ModelName}}_steadystate (const gsl_vector *, void *, gsl_vector *);
    {% endif %}

{% endif %}

  class {{ModelName}} : public Archiving_Node { 

   public:

    ~{{ModelName}}();
    {{ModelName}}(const {{ModelName}} &);
    {{ModelName}}();

    using Node::connect_sender;
    using Node::handle;

    port check_connection(Connection&, port);
	  
    void handle(SpikeEvent &);
    void handle(CurrentEvent &);
    void handle(DataLoggingRequest &); 
  
    port connect_sender(SpikeEvent &, port);
    port connect_sender(CurrentEvent &, port);
    port connect_sender(DataLoggingRequest &, port);
  
    void get_status(DictionaryDatum &) const;
    void set_status(const DictionaryDatum &);
  
    void init_node_(const Node& proto);
    void init_state_(const Node& proto);
    void init_buffers_();
    void calibrate();
  
    void update(Time const &, const long_t, const long_t);

    /**
     * Minimal spike receptor type.
     * @note Start with 1 so we can forbid port 0 to avoid accidental
     *     creation of connections with no receptor type set.
     */
    static const port MIN_SPIKE_RECEPTOR = 1;

    /** 
     * Spike receptors.
     */
    enum SpikeSynapseTypes {
{% if synaptic_events %}
      {{synaptic_events[0]}}_SPIKE_RECEPTOR = MIN_SPIKE_RECEPTOR,
{% endif %}
{% for name in synaptic_events[1:] %}
      {{name}}_SPIKE_RECEPTOR,
{% endfor %}
      SUP_SPIKE_RECEPTOR
    };
  
    // Set dynamics methods (the ones that actually model the dynamics) as friends
{% if (ODEmethod == "cvode") %}
    friend int {{ModelName}}_dynamics (double, const N_Vector, N_Vector, void*);
    friend int {{ModelName}}_event (double, N_Vector, double *, void*);
{% elif (ODEmethod == "ida") %}
    friend int {{ModelName}}_residual (double, N_Vector, N_Vector, N_Vector, void*);
    friend int {{ModelName}}_event (double, N_Vector, N_Vector, double *, void*);
{% elif (ODEmethod == "gsl") %}
    friend int {{ModelName}}_dynamics (double, const double*, double*, void*);
{% endif %} 
{% if (steadyStateSize > 0) %}
    {% if (SSmethod == "kinsol") %}
    friend  int {{ModelName}}_steadystate (N_Vector, N_Vector, void*);
    {% else %}
    friend  int {{ModelName}}_steadystate (const gsl_vector *, void *, gsl_vector *);
    {% endif %}
{% endif %}
    // Synaptic Events
{% for name in synaptic_events %}
    int {{name}}_transients (long_t lag);
{% endfor %}

    // The next two classes need to be friends to access the State_ class/member
    friend class RecordablesMap<{{ModelName}}>;
    friend class UniversalDataLogger<{{ModelName}}>;


    struct Parameters_ { 
{% for name in parameter_names %}
      double {{name}};
{% endfor %}
      Parameters_();
      void get(DictionaryDatum&) const;
      void set(const DictionaryDatum&);
    }; // end struct Parameters_


    struct State_ { 

      enum StateVecElems {
        {{state_variables[0]}}_i = 0,
{% for i, state in enumerate(state_variables[1:]) %}
        {{state}}_i, // {{i + 1}}
{% endfor %}
        STATE_VEC_SIZE_
      };
	
      double y_[STATE_VEC_SIZE_]; 
		
      State_(const Parameters_& p); 
      State_(const State_& s);
      State_& operator=(const State_& s);
      void get(DictionaryDatum&) const;
      void set(const DictionaryDatum&, const Parameters_&);
{% if (ODEmethod == "gsl") %}
      int_t r_; /* refractory counter */
{% endif %}

    }; // end struct State_


{% if ((ODEmethod == "cvode") or (ODEmethod == "ida"))  %}
    struct Variables_ {};
{% elif (ODEmethod == "gsl")  %}
    struct Variables_ { int_t RefractoryCounts_; double U_old_; /* for spike-detection */ };
{% endif %}


    struct Buffers_ {

      Buffers_({{ModelName}}&);
      Buffers_(const Buffers_&, {{ModelName}}&);
      UniversalDataLogger<{{ModelName}}> logger_;
	
{% if (ODEmethod == "cvode") %}
      N_Vector y;  //!< current state vector used by CVode
      void *   sys_;  //!< CVode control structure
{% elif (ODEmethod == "ida") %}
      N_Vector y, y1;  //!< current state vector used by IDA
      N_Vector yp;  //!< derivatives vector used by IDA
      void *   sys_;  //!< IDA control structure
{% elif (ODEmethod == "gsl") %}
      gsl_odeiv2_step*  s_;  //!< stepping function
      gsl_odeiv2_control* c_;  //!< adaptive stepsize control function
      gsl_odeiv2_evolve*  e_;  //!< evolution function
      gsl_odeiv2_system   sys_;  //!< struct describing system
      unsigned int N;  // size of state vector used by Jacobian
      double *u, *jac;  // intermediate state vectors used for Jacobian approximation
{% endif %}
{% for id in synaptic_event_pscIDs %}
      RingBuffer spike_{{id}};
{% endfor %}

	  RingBuffer currents_;
	
	  double_t step_;       //!< step size in ms
	  double   IntegrationStep_;//!< current integration time step, updated by solver
	
	  /** 
	   * Input current injected by CurrentEvent.
	   * This variable is used to transport the current applied into the
	   * _dynamics function computing the derivative of the state vector.
	   * It must be a part of Buffers_, since it is initialized once before
	   * the first simulation, but not modified before later Simulate calls.
	  */
	  double_t I_stim_;
	
	}; // end struct Buffers_


	template <State_::StateVecElems elem>
	double_t get_y_elem_() const { return S_.y_[elem]; }
	
	Parameters_ P_;
	State_      S_;
	Variables_  V_;
	Buffers_    B_;
	
    //! Mapping of recordables names to access functions	
	static RecordablesMap<{{ModelName}}> recordablesMap_;

  }; // end class {{ModelName}}


  inline port {{ModelName}}::check_connection(Connection& c, port receptor_type) {
	  SpikeEvent e;
	  e.set_sender(*this);
	  c.check_event(e);
	  return c.get_target()->connect_sender(e, receptor_type);
  }


  inline port {{ModelName}}::connect_sender(SpikeEvent&, port receptor_type) {
    if (receptor_type < 0 || receptor_type >= SUP_SPIKE_RECEPTOR)
      throw UnknownReceptorType(receptor_type, get_name());
    else if (receptor_type < MIN_SPIKE_RECEPTOR)
      throw IncompatibleReceptorType(receptor_type, get_name(), "SpikeEvent");
    return receptor_type;
  }
 

  inline port {{ModelName}}::connect_sender(CurrentEvent&, port receptor_type) {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return 0;
  }


  inline port {{ModelName}}::connect_sender(DataLoggingRequest& dlr, port receptor_type) {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return B_.logger_.connect_logging_device(dlr, recordablesMap_);
  }


  inline void {{ModelName}}::get_status(DictionaryDatum &d) const {
    P_.get(d);
    S_.get(d);
    Archiving_Node::get_status(d);
    (*d)[names::recordables] = recordablesMap_.get_list();
    def<double_t>(d, names::t_spike, get_spiketime_ms());
    DictionaryDatum receptor_dict_ = new Dictionary();
    // Synaptic event dictionary
{% for name in synaptic_events %}
    (*receptor_dict_)[Name("{{name}}")]  = {{name}}_SPIKE_RECEPTOR;
{% endfor %}
    (*d)[names::receptor_types] = receptor_dict_;
  }


  inline void {{ModelName}}::set_status(const DictionaryDatum &d) {
    Parameters_ ptmp = P_;  // temporary copy in case of errors
    ptmp.set(d);             // throws if BadProperty
    State_    stmp = S_;  // temporary copy in case of errors
    stmp.set(d, ptmp);         // throws if BadProperty
    // We now know that (ptmp, stmp) are consistent. We do not 
    // write them back to (P_, S_) before we are also sure that 
	// the properties to be set in the parent class are internally 
	// consistent.
	Archiving_Node::set_status(d);
	// if we get here, temporaries contain consistent set of properties
	P_ = ptmp;
	S_ = stmp;	
    calibrate();
  }

} // end namespace nest


// ------------------- NEST-header.tmpl ------------------------//
