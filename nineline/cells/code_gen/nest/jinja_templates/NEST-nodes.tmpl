{# This template provides the code to generate and access nodes

   Authors: Ivan Raikov and Thomas G. Close
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//-------------------------------------------------//
// This section was generated from NEST-nodes.tmpl //
//-------------------------------------------------//
{{ModelName}}::{{ModelName}}()
    : Archiving_Node(), 
      P_(), 
      S_(P_),
      B_(*this) {
    recordablesMap_.create();
}

{{ModelName}}::{{ModelName}}(const {{ModelName}}& n)
    : Archiving_Node(n), 
      P_(n.P_), 
      S_(n.S_),
      B_(n.B_, *this) {}

void {{ModelName}}::init_node_(const Node& proto) {
    const {{ModelName}}& pr = downcast<{{ModelName}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}

void {{ModelName}}::init_state_(const Node& proto) {
    const {{ModelName}}& pr = downcast<{{ModelName}}>(proto);
    S_ = State_(pr.P_);
}

void {{ModelName}}::init_buffers_() {

    {% for name in event_port_names %}
    B_.{{name}}_event_port.clear();
    {% endfor %}
    
    B_.currents_.clear();           
    Archiving_Node::clear_history();
    
    B_.logger_.reset();
    
    B_.step_ = Time::get_resolution().get_ms();
    B_.IntegrationStep_ = B_.step_;
    
    B_.I_stim_ = 0.0;

    {% include NEST-init-solver.tmpl %}    
}


void {{ModelName}}::calibrate() {
    B_.logger_.init();  
{% if (ode_method == "gsl") %}
    V_.U_old_ = S_.y_[{{ModelName}}::State_::{{membrane_voltage}}_i];
    {% if refractory_period %}
    V_.RefractoryCounts_ = Time(Time::ms(P_.t_ref)).get_steps();
    {% else %}
    V_.RefractoryCounts_ = 0;
    {% endif %}
{% endif %}
}
// ------------------- NEST-nodes.tmpl ------------------------//
