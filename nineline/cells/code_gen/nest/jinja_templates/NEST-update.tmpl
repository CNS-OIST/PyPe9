{#
   NEST update template 

   This template defines a C++ function of the form:

   int ModelName_update (Time const & origin, const long_t from, const long_t to)

   This is the model state update function invoked by the NEST simulator.

   Template variables are:

   - ode_method: the current used solver method; can be "cvode" "ida" or "gsl"
   - ModelName: the name of the current system
   - stateIndexMap - a dictionary mapping state names to state vector indices
                     (state "v" is always at index 0)

   This template invokes the "NEST-emit-spike.tmpl" template in order
   to generate code that handles detection of spiking threshold and
   generation of corresponding spike events.

   Authors: Ivan Raikov and Thomas G. Close
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//-------------------------------------------- -----//
// This section was generated from NEST-update.tmpl //
//--------------------------------------------------//
void {{ModelName}}::update(Time const & origin, const long_t from, const long_t to) {

    assert(to >= 0 && (delay) from < Scheduler::get_min_delay());
    assert(from < to);

    double tout; // FIXME: What is this? it not set anywhere...
    long_t current_steps = origin.get_steps();

    for ( long_t lag = from ; lag < to ; ++lag ) {
      double h = B_.step_;    
	double tt = 0.0;

{% if ode_method == "cvode" %}
    int N = NV_LENGTH_S (B_.y);
    tout = (current_steps+lag)*h;

	// adaptive step integration
	while (tt < tout) {
	  const int status = CVode (B_.sys_, tout, B_.y, &tt, CV_NORMAL);

        switch (status) {
          case CV_SUCCESS:      continue;
          case CV_ROOT_RETURN:  {% include "NEST-emit-spike-cvode.tmpl" %};
          default:              throw CVodeSolverFailure (get_name(), 0);
        }
   	}

    for (int i = 0; i < N; i++) {
       S_.y_[i] = ITEM(B_.y, i);
    }
    
    {% include "NEST-solver-events.tmpl" %}

{% elif ode_method == "ida" %}
    int N = NV_LENGTH_S (B_.y);
    tout = (current_steps+lag)*h;

	// adaptive step integration
	while (tt < tout) {
	  const int status = IDASolve (B_.sys_, tout, &tt, B_.y, B_.yp, IDA_NORMAL);

      switch (status) {
        case IDA_SUCCESS:      continue;
        case IDA_ROOT_RETURN:  {% include "NEST-emit-spike-cvode.tmpl" %};
        case IDA_TSTOP_RETURN: break;
        default:               throw IDASolverFailure (get_name(), 0);
      }
   	}

    for (int i = 0; i < N; i++) {
     S_.y_[i] = ITEM(B_.y, i);
    }
    
    {% include "NEST-solver-events.tmpl" %}

{% elif ode_method == "gsl" %}
    V_.U_old_ = S_.y_[{{ModelName}}::State_::{{membrane_voltage}}_INDEX];

    while (tt < h) {
      const int status =  gsl_odeiv2_evolve_apply(B_.e_, B_.c_, B_.s_, 
                                                  &B_.sys_, // system of ODE
                                                  &tt, // from t...
                                                  h, // ...to t=t+h
                                                  &B_.IntegrationStep_, // integration window (written on!)
                                                  S_.y_); // neuron state

      if ( status != GSL_SUCCESS )
        throw GSLSolverFailure(get_name(), status);
    }
    
    {% include "NEST-emit-spike-gsl.tmpl" %}
    
    {% include "NEST-solver-events.tmpl" %}

{% endif %}

{# Event handling #}
    // Event handling (still needs to handle events that arrive in the same
    // timestep.
{% if len(regimes) > 1 %}
    int transition = 0;
{% endif %}
{% for regime in regimes %}
    {%+ if not loop.first %}} else {% endif %}if (B_.current_regime == {{regime.name}}_REGIME) {
    {% for on_event in regime.on_events %}
        {%+ if not loop.first %}} else {% endif %}if (B_.{{on_event.src_port_name}}_event_port.get_value(lag)) {
        {% if on_event.target_regime != regime %}
            if (transition)
                std::cout << "Warning!: multiple transitions in the same time step. Transition " << transition << " was ignored in favour of transition " << {{on_event.target_regime.name}}_REGIME << "." << std::endl;  
            transition = {{on_event.target_regime.name}}_REGIME;
        {% endif %}
            {{on_event.src_port_name}}_transient_in_{{regime.name or 'default'}}(lag);
        {% if loop.last %}
        }
        {% endif %}
    {% endfor %}
    {% if loop.last %}
    }    
    {% endif %}    
{% endfor %}

{% for name in analog_port_names %}
    B_.{{name}}_value = B_.{{name}}_analog_port.get_value(lag);
{% endfor %}    
    B_.logger_.record_data(current_steps + lag);
  }
}
//------------- NEST-update.tmpl -------------//