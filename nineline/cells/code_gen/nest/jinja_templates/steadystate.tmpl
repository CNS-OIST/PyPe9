{#
   NEST steady state template 

   This template defines a C++ function of the form:

   int ModelName_steadystate (N_Vector u, N_Vector f, void* pnode)

   if using the KINSOL solver, or 

   int ModelName_steadystate (const gsl_vector *u, void *pnode, gsl_vector *f)

   if using the GSL steady state solver.
   The function computes the derivatives of all states defined in the system.

   Template variables are:

   - ode_solver: the current used solver method; can be "cvode" "ida" or "gsl"
   - ModelName: the name of the current system
   - vars: list of strings with the name of all local variables appearing in the system
   - SSgetStateDefs - equations of the form "n = u[i]"  where "n" is the name of a state,
                      and "i" is the index corresponding to that state in the steady state vector.
   - initOrder - topologically sorted list of strings with
                 external, assignment, initial, pool equations in C++ syntax
   - SScurrentEqDefs - equations of the form "i_{{name}} = 0.0" that set all ionic currents to 0
   - SSsetStateDefsLbs - list of objects of with the following fields:
                           - lbs - local variables used in steady state expressions
                           - defs - list of equations of the form "f[i] = rhs" where "i" is the index of a state,
                             and "rhs" is the corresponding derivative expr for that state
   
   Authors: Ivan Raikov and Thomas G. Close
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//-------------------------------------------------------//
// This section was generated from NEST-steadystate.tmpl //
//-------------------------------------------------------//
{% if steady_state_method == "kinsol" %}
  int fsolve (KINSysFn f, int N, N_Vector fval, void *user_data,
              std::string name) {
      int status;
      N_Vector u0, sc;
      void *kmem;

      u0 = N_VNew_Serial(N);
      N_VConst_Serial(0.0,u0); 
      N_VConst_Serial(0.0,fval); 

      sc = N_VNew_Serial(N);
      N_VConst_Serial(1.0,sc); 

      kmem = KINCreate();

      status = KINSetUserData (kmem, user_data);
      if (check_flag (&status, "KinSetUserData", 1))
        throw KINSolverFailure (name, status);

      status = KINInit (kmem, f, u0);
      if (check_flag (&status, "KinInit", 1))
        throw KINSolverFailure (name, status);

      status = KINDense (kmem, N);
      if (check_flag (&status, "KinDense", 1))
        throw KINSolverFailure (name, status);

      status = KINSol (kmem, fval, KIN_NONE, sc, sc);
      if (check_flag (&status, "KINSol", 1))
        throw KINSolverFailure (name, status);
      
      N_VDestroy_Serial(sc);
      N_VDestroy_Serial(u0);

      KINFree (&kmem);

      return 0;
  }
{% elif steady_state_method == "gsl" %}
  int fsolve (int (*fss)(const gsl_vector *, void *user_data, gsl_vector *),
              int N, gsl_vector *fval, void *user_data, std::string name) {
      
      const gsl_multiroot_fsolver_type * T = gsl_multiroot_fsolver_hybrid;
      gsl_multiroot_fsolver * s = gsl_multiroot_fsolver_alloc (T, N);
      gsl_multiroot_function f = {fss, N, user_data};

      int status, iter;
      gsl_vector *x = gsl_vector_alloc (N);
      for (int i = 0; i < N; i++)
         gsl_vector_set (x, i, 0.0);
      gsl_multiroot_fsolver_set (s, &f, x);

      iter = 0;
      do {
         iter++;
         status = gsl_multiroot_fsolver_iterate (s);
         if ((status == GSL_EBADFUNC) || (status == GSL_ENOPROG))
            throw GSLSolverFailure(name, status);
         status =  gsl_multiroot_test_residual (s->f, 1e-7);
      } while (status == GSL_CONTINUE && iter < 1000);

      for (int i = 0; i < N; i++)
         gsl_vector_set (fval, i, gsl_vector_get (s->x, i));

      gsl_vector_free (x);
      gsl_multiroot_fsolver_free (s);

      return 0;
  }
{% endif %}

{% if steady_state_method == "kinsol" %}
extern "C" int {{ModelName}}_steadystate (N_Vector u, N_Vector f, void* pnode) {
{% else %}
extern "C" int {{ModelName}}_steadystate (const gsl_vector *u, void *pnode, gsl_vector *f) {
{% endif %}
{#
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{ModelName}}::Parameters_* params = (struct {{ModelName}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
#}
   return 0;
}
//---------------- NEST-steadystate.tmpl ---------------//