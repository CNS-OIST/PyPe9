{#
   NEST update template 

   This template defines a C++ function of the form:

   int ModelName_update (Time const & origin, const long_t from, const long_t to)

   This is the model state update function invoked by the NEST simulator.

   Template variables are:

   - ode_solver: the current used solver method; can be "cvode" "ida" or "gsl"
   - ModelName: the name of the current system
   - stateIndexMap - a dictionary mapping state names to state vector indices
                     (state "v" is always at index 0)

   This template invokes the "NEST-emit-spike.tmpl" template in order
   to generate code that handles detection of spiking threshold and
   generation of corresponding spike events.

   Authors: Ivan Raikov and Thomas G. Close
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

//---------------------------------------------//
// This section was generated from update.tmpl //
//---------------------------------------------//
void {{ModelName}}::update(Time const & origin, const long_t from, const long_t to) {

    assert(to >= 0 && (delay) from < Scheduler::get_min_delay());
    assert(from < to);

    long_t current_steps = origin.get_steps();

    for (long_t lag = from; lag < to; ++lag) {
        double dt = B_.step_;    
        double tt = 0.0;

{% if ode_solver in ('cvode', 'ida') %}
	    int N = NV_LENGTH_S (B_.y);
	    double tout = (current_steps+lag) * dt;
	
		// adaptive step integration
        while (tt < tout) {
            const int status = {{solver_name}} (B_.sys_, tout, &tt, B_.y{% if ode_solver == 'ida' %}, B_.yp{% endif %}, {{solver_abbrev}}_NORMAL);
            switch (status) {
                case {{solver_abbrev}}_SUCCESS:      continue;
                case {{solver_abbrev}}_ROOT_RETURN: {
                    set_spiketime(Time::ms(tt));
	                SpikeEvent se;
	                // Copy solver state to NEST state
	                for (int i = 0; i < N; i++)
	                    S_.y_[i] = ITEM(B_.y,i);
	                network()->send(*this, se, lag);
	                adjust_zero_crossings(B_.y, {{abs_tolerance}});
                    continue;
                }
                case {{solver_abbrev}}_TSTOP_RETURN: break;
                default:
                    throw {{solver_prefix}}SolverFailure (get_name(), 0);
            }
	   	}
	
        // Copy items from CVODE/IDA vector to NEST state array.
	    for (int i = 0; i < N; i++)
	       S_.y_[i] = ITEM(B_.y, i);
{% elif ode_solver == "gsl" %}
	    V_.U_old_ = S_.y_[{{ModelName}}::State_::{{membrane_voltage}}_INDEX];
	
	    while (tt < dt) {
	      const int status =  gsl_odeiv2_evolve_apply(B_.e_, B_.c_, B_.s_, 
	                                                  &B_.sys_, // system of ODE
	                                                  &tt, // from t...
	                                                  dt, // ...to t= t + dt
	                                                  &B_.IntegrationStep_, // integration window (written on!)
	                                                  S_.y_); // neuron state
	      if (status != GSL_SUCCESS)
	        throw GSLSolverFailure(get_name(), status);
	    }
	    
		// Check threshold if not refractory and emit spike if crossed
	    if ( S_.r_ > 0 )
	       S_.r_--;
	    else if (S_.y_[{{ModelName}}::State_::{{membrane_voltage}}_INDEX] >= P_.V_t &&
	             V_.U_old_ > S_.y_[{{ModelName}}::State_::{{membrane_voltage}}_INDEX]) {
	        S_.r_ = V_.RefractoryCounts_;
	        set_spiketime(Time::step(origin.get_steps()+lag+1));
	        SpikeEvent se;
	        network()->send(*this, se, lag);
	    }
{% endif %}

{# Event handling #}
	    // Event handling (still needs to handle events that arrive in the same
	    // timestep.
	    int num_events = 0;
{% if len(regimes) > 1 %}
    int transition = 0;
{% endif %}
{% for regime in regimes %}
        {%+ if not loop.first %}} else {% endif %}if (B_.current_regime == {{regime.name}}_REGIME) {
    {% for on_event in regime.on_events %}
            {%+ if not loop.first %}} else {% endif %}if (B_.{{on_event.src_port_name}}_event_port.get_value(lag)) {
        {% if on_event.target_regime != regime %}
	            if (transition)
	                std::cout << "Warning!: multiple transitions in the same time step. Transition " << transition << " was ignored in favour of transition " << {{on_event.target_regime.name}}_REGIME << "." << std::endl;  
	            transition = {{on_event.target_regime.name}}_REGIME;
        {% endif %}
	            {{on_event.src_port_name}}_transient_in_{{regime.name or 'default'}}(lag);
	            ++num_events;
        {% if loop.last %}
            }
        {% endif %}
    {% endfor %}
    {% if loop.last %}
        }    
    {% endif %}    
{% endfor %}
	    /* 
	     * FIXME:
	     * Not sure if this is necessary, Ivan thought it was but I haven't seen it
	     * in NEST examples
	     */
	    if (num_events > 0) {
{% if (ode_solver == "cvode") %}
	        /* Reinitializes CVode state if any synaptic events have occurred */
	        int status = CVodeReInit(B_.sys_, tt, B_.y);
	        if (check_flag(&status, "CVodeReInit", 1))
	            throw CVodeSolverFailure(get_name(), status);
{% elif (ode_solver == "ida") %}
	        /* Reinitializes IDA state if any synaptic events have occurred */
	        int status = IDAReInit(B_.sys_, tt, B_.y, B_.yp);
	        if (check_flag(&status, "IDAReInit", 1))
	            throw IDASolverFailure(get_name(), status);
{% elif (ode_solver == "gsl") %}
	        /* Resets the GSL stepping function if any synaptic events have occurred */
	        gsl_odeiv2_step_reset(B_.s_);
{% endif %}
        }

{% for name in analog_port_names %}
        B_.{{name}}_value = B_.{{name}}_analog_port.get_value(lag);
{% endfor %}    
        B_.logger_.record_data(current_steps + lag);
    }
}
//------------- update.tmpl -------------//