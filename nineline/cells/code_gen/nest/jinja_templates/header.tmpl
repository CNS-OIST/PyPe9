{# This template provides a CVODE exception class

   Authors: Ivan Raikov and Thomas G. Close
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

/* This file was generated by NineLine version {{version}} on {{timestamp}} */

{% include "header-includes.tmpl" %}

namespace nest {

{% include "solver-preludes.tmpl" %}

{% if ode_solver == "cvode" %}
    extern "C" int {{ModelName}}_dynamics (double, const N_Vector, N_Vector, void*);
    extern "C" int {{ModelName}}_event (double, N_Vector, double *, void*);
{% elif ode_solver == "ida" %}
    extern "C" int {{ModelName}}_residual (double, N_Vector, N_Vector, N_Vector, void*);
    extern "C" int {{ModelName}}_event (double, N_Vector, N_Vector, double *, void*);
{% elif ode_solver == 'gsl' %}
    extern "C" int {{ModelName}}_dynamics (double, const double*, double*, void*);
{% endif %}
{% if ss_solver == "kinsol" %}
    extern "C" int {{ModelName}}_steadystate (N_Vector, N_Vector, void*);
{% elif ss_solver == 'gsl' %}
    extern "C" int {{ModelName}}_steadystate (const gsl_vector *, void *, gsl_vector *);
{% endif %}

  class {{ModelName}} : public Archiving_Node { 

   public:

    ~{{ModelName}}();
    {{ModelName}}(const {{ModelName}} &);
    {{ModelName}}();

    /**
     * Import sets of overloaded virtual functions.
     * This is necessary to ensure proper overload and overriding resolution.
     * @see http://www.gotw.ca/gotw/005.htm.
     */
    using Node::connect_sender;
    using Node::handle;

    port check_connection(Connection&, port);
	  
    void handle(SpikeEvent &);
    void handle(CurrentEvent &);
    void handle(DataLoggingRequest &); 
  
    port connect_sender(SpikeEvent &, port);
    port connect_sender(CurrentEvent &, port);
    port connect_sender(DataLoggingRequest &, port);
  
    void get_status(DictionaryDatum &) const;
    void set_status(const DictionaryDatum &);
  
    void init_node_(const Node& proto);
    void init_state_(const Node& proto);
    void init_buffers_();
    void calibrate();
  
    void update(Time const &, const long_t, const long_t);
  
    // Set dynamics methods (the ones that actually model the dynamics) as friends
{% if (ode_solver == "cvode") %}
    friend int {{ModelName}}_dynamics (double, const N_Vector, N_Vector, void*);
    friend int {{ModelName}}_event (double, N_Vector, double *, void*);
{% elif (ode_solver == "ida") %}
    friend int {{ModelName}}_residual (double, N_Vector, N_Vector, N_Vector, void*);
    friend int {{ModelName}}_event (double, N_Vector, N_Vector, double *, void*);
{% elif (ode_solver == "gsl") %}
    friend int {{ModelName}}_dynamics (double, const double*, double*, void*);
{% endif %} 
{% if ss_solver == "kinsol" %}
    friend  int {{ModelName}}_steadystate (N_Vector, N_Vector, void*);
{% elif ss_solver == 'gsl' %}
    friend  int {{ModelName}}_steadystate (const gsl_vector *, void *, gsl_vector *);
{% endif %}

    // Regime ids
    static const int DEFAULT_REGIME_ = 0;    
    enum Regimes {
        {% for name in regime_names %}
            {% if loop.first %}
        {{name}}_REGIME = DEFAULT_REGIME_,
            {% else %}
        {{name}}_REGIME,
            {% endif -%}  
        {% endfor %}
        SUP_REGIME_
    };
    
{% if event_port_names %}
    /* Event port ids
     * @note Start with 1 so we can forbid port 0 to avoid accidental
     *     creation of connections with no receptor type set.
     */
    static const port MIN_EVENT_PORT_ = 1;
    enum EventPorts {
    {% for name in event_port_names %}
        {% if loop.first %}
        {{name}}_EVENT_PORT = MIN_EVENT_PORT_,
        {% else %}
        {{name}}_EVENT_PORT,
        {% endif %}
    {% endfor %}
        SUP_EVENT_PORT_
    };

    // On event ids
    enum OnEvents {
        {% for name in on_event_names %}
        {{name}}_ON_EVENT,
        {% endfor %}
        SUP_ON_EVENT_
    };

{% endif %}
{% if analog_port_names %}
    //Analog port ids
    static const port MIN_ANALOG_PORT_ = {% if event_port_names %}SUP_EVENT_PORT_{% else %}1{% endif %};
    enum AnalogPorts {
    {% for name in analog_port_names %}
        {% if loop.first %}
        {{name}}_ANALOG_PORT = MIN_ANALOG_PORT_,
        {% else %}
        {{name}}_ANALOG_PORT,
        {% endif %}
    {% endfor %}
        SUP_ANALOG_PORT_
    };
    
{% endif %}
    // Synaptic event function definitions
{% for func_name, _, _ in transients %}
    inline void {{func_name}}(long_t lag);
{% endfor %}

    // The next two classes need to be friends to access the State_ class/member
    friend class RecordablesMap<{{ModelName}}>;
    friend class UniversalDataLogger<{{ModelName}}>;

    struct Parameters_ { 
{% for name in parameter_names %}
        double {{name}};
{% endfor %}
        Parameters_();
        void get(DictionaryDatum&) const;
        void set(const DictionaryDatum&);
    }; // end struct Parameters_

    struct State_ { 

      enum StateVecElems {
{% for name in state_variables %}
    {% if loop.first %}
        {{name}}_INDEX = 0,
    {% else %}
        {{name}}_INDEX,
    {% endif %}
{% endfor %}
        STATE_VEC_SIZE_
      };
	
      double y_[STATE_VEC_SIZE_];
{% if (ode_solver == "gsl") %}
      int_t r_; /* refractory counter */
{% endif %}
		
      State_(const Parameters_& p); 
      State_(const State_& s);
      State_& operator=(const State_& s);
      void get(DictionaryDatum&) const;
      void set(const DictionaryDatum&, const Parameters_&);
    }; // end struct State_


{% if ode_solver in ("cvode", "ida") %}
    struct Variables_ {};
{% elif (ode_solver == "gsl")  %}
    struct Variables_ { int_t RefractoryCounts_; double U_old_; /* for spike-detection */ };
{% endif %}

    struct Buffers_ {

        Buffers_({{ModelName}}&);
        Buffers_(const Buffers_&, {{ModelName}}&);
        UniversalDataLogger<{{ModelName}}> logger_;

        // Structures required by the solver
{% if ode_solver == "cvode" %}
        N_Vector y;  //!< current state vector used by CVode
        void *   sys_;  //!< CVode control structure
{% elif ode_solver == "ida" %}
        N_Vector y, y1;  //!< current state vector used by IDA
        N_Vector yp;  //!< derivatives vector used by IDA
        void *   sys_;  //!< IDA control structure
{% elif ode_solver == "gsl" %}
		gsl_odeiv2_step*  s_;  //!< stepping function
		gsl_odeiv2_control* c_;  //!< adaptive stepsize control function
		gsl_odeiv2_evolve*  e_;  //!< evolution function
		gsl_odeiv2_system   sys_;  //!< struct describing system
		unsigned int N;  // size of state vector used by Jacobian
		double *u, *jac;  // intermediate state vectors used for Jacobian approximation
{% endif %}

        // Timesteps
        double_t step_;       //!< step size in ms
        double   IntegrationStep_;//!< current integration time step, updated by solver
    
        // Event receive port buffers
{% for name in event_port_names %}
        RingBuffer {{name}}_event_port;
{% endfor %}

        // Analog receive port buffers
{% for name in analog_port_names %}
        RingBuffer {{name}}_analog_port;
{% endfor %}

        // Variables to hold the last value of the analog receive port buffers        
{% for name in analog_port_names %}
        double_t {{name}}_value;
{% endfor %}
        
        // Holds the id of the current regime
        int current_regime;
	
	}; // end struct Buffers_


	template <State_::StateVecElems elem>
	double_t get_y_elem_() const { return S_.y_[elem]; }
	
	Parameters_ P_;
	State_      S_;
	Variables_  V_;
	Buffers_    B_;
	
    //! Mapping of recordables names to access functions	
	static RecordablesMap<{{ModelName}}> recordablesMap_;

  }; // end class {{ModelName}}


  inline port {{ModelName}}::check_connection(Connection& c, port receptor_type) {
	  SpikeEvent e;
	  e.set_sender(*this);
	  c.check_event(e);
	  return c.get_target()->connect_sender(e, receptor_type);
  }


  inline port {{ModelName}}::connect_sender(SpikeEvent&, port receptor_type) {
    if (receptor_type < 0 || receptor_type >= SUP_EVENT_PORT_)
      throw UnknownReceptorType(receptor_type, get_name());
    else if (receptor_type < MIN_EVENT_PORT_)
      throw IncompatibleReceptorType(receptor_type, get_name(), "SpikeEvent");
    return receptor_type;
  }
 

  inline port {{ModelName}}::connect_sender(CurrentEvent&, port receptor_type) {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return 0;
  }


  inline port {{ModelName}}::connect_sender(DataLoggingRequest& dlr, port receptor_type) {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return B_.logger_.connect_logging_device(dlr, recordablesMap_);
  }


  inline void {{ModelName}}::get_status(DictionaryDatum &d) const {
    P_.get(d);
    S_.get(d);
    Archiving_Node::get_status(d);
    (*d)[names::recordables] = recordablesMap_.get_list();
    def<double_t>(d, names::t_spike, get_spiketime_ms());
    DictionaryDatum receptor_dict_ = new Dictionary();
    // Synaptic event dictionary
{% for name in event_port_names %}
    (*receptor_dict_)[Name("{{name}}")]  = {{name}}_EVENT_PORT;
{% endfor %}
    (*d)[names::receptor_types] = receptor_dict_;
  }


  inline void {{ModelName}}::set_status(const DictionaryDatum &d) {
    Parameters_ ptmp = P_;  // temporary copy in case of errors
    ptmp.set(d);             // throws if BadProperty
    State_    stmp = S_;  // temporary copy in case of errors
    stmp.set(d, ptmp);         // throws if BadProperty
    // We now know that (ptmp, stmp) are consistent. We do not 
    // write them back to (P_, S_) before we are also sure that 
	// the properties to be set in the parent class are internally 
	// consistent.
	Archiving_Node::set_status(d);
	// if we get here, temporaries contain consistent set of properties
	P_ = ptmp;
	S_ = stmp;	
    calibrate();
  }

} // end namespace nest
